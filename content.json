{"meta":{"title":"七味和弦","subtitle":null,"description":null,"author":"七味和弦","url":"jaminchanks.github.io.git"},"pages":[{"title":"Hello World123","date":"2020-07-18T17:31:26.224Z","updated":"2020-07-18T17:31:26.221Z","comments":true,"path":"模板.html","permalink":"jaminchanks.github.io.git/模板.html","excerpt":"","text":""},{"title":"About","date":"2020-07-18T17:22:54.048Z","updated":"2018-01-18T13:57:21.349Z","comments":true,"path":"about/index.html","permalink":"jaminchanks.github.io.git/about/index.html","excerpt":"","text":"这家伙很懒，什么都没有留下。"},{"title":"Categories","date":"2020-07-18T17:22:54.060Z","updated":"2017-10-24T10:05:25.942Z","comments":true,"path":"categories/index.html","permalink":"jaminchanks.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-07-18T17:22:54.756Z","updated":"2017-10-24T10:05:25.942Z","comments":true,"path":"tags/index.html","permalink":"jaminchanks.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Git/git_我可以反悔吗","date":"2018-06-28T13:57:36.094Z","updated":"2018-06-28T13:57:36.094Z","comments":true,"path":"2018/06/28/Git/git_我可以反悔吗/","link":"","permalink":"jaminchanks.github.io.git/2018/06/28/Git/git_我可以反悔吗/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Git 深入学习笔记","slug":"Git/git_笔记1","date":"2018-05-31T15:24:25.980Z","updated":"2018-05-31T18:32:53.786Z","comments":true,"path":"2018/05/31/Git/git_笔记1/","link":"","permalink":"jaminchanks.github.io.git/2018/05/31/Git/git_笔记1/","excerpt":"今天学校改名成功了……","text":"今天学校改名成功了…… Git 基础Git的诞生 作为最知名的开源项目之一，linux内核开源项目有着为数众多的参与者。但对于项目维护者和参与者而言，他们花费了太多时间在提交补丁和保存归档的繁琐事务上了。直到2002年，linux内核项目组开始使用了一个分布式版本控制系统BitKeeper来管理和维护代码。 但与BitKeeper的合作关系仅持续到了2005。合作关系结束后，linux内核项目组不再免费使用BitKeeper，于是linux开源社区，尤其是林姓同学(Linux Torvalds)，通过吸取过去使用BitKeeper时得到的经验教训，开发出了Git。 对于新开发出来的这个版本控制系统，他们提出了以下目标： 速度 简单设计 对非线性开发模式的强力支持(最起码支持上千的并行分支) 完全分布式 能高效管理像Linux这样的大型项目 自诞生以来，Git已经变得越来越完善了。在保持易用性的同时，也保留着最初所设定的目标。 工作流程记录快照，而非差异 Git与其他的版本控制工具(如SVN)的主要差别是，大部分的版本控制工具记录的是每次提交时文件与原始文件的差异。 而Git则是在每次提交更新或保存项目状态时，对当前的全部文件制作一个快照并保存这个快照的索引。为了高效，如果某个文件自上次提交之后没有修改过，那么Git不会重新存储该文件，而是只保留一个链接指向之前存储的文件。从某个角度上看，Git就像一个小型的文件管理系统。 近乎所有操作都是在本地进行的 绝大部分的Git操作只需要对本地的文件和资源进行操作，而不需要用到来自网络上其他计算机的信息。在本地磁盘上你就拥有一个整个项目的完整提交历史。也就是说，即使你处于离线状态下，你也能查看整个项目的每一次提交的历史记录，并且照样的修改和提交文件到本地。等到了下次联网的情况，再将项目的提交历史共享给其他项目参与者。 Git保证完整性 Git在存储任何文件之前都会为该文件的内容计算 校验和, 而Git在稍后也通过校验和来引用本次修改/提交。这也意味着，无法在Git不知情的情况下更改任何文件内容或目录内容。如果在传输或获取文件的过程文件的内容丢失，Git都能第一时间发现。 Git采用SHA-1哈希算法来计算校验和，计算结果基于Git中文件的内容或目录结构，由40个十六进制字符(0-9 和 a-f)组成，计算结果大致如下:18a81aebd04e5bed11504d398616aa4b835070ce6 Git 通常只增加文件 你执行的绝大部分操作其实都是往Git数据库中增加数据。一旦你提交快照到Git中，就很难让Git执行任何无法逆转的操作或让其擦除数据。当然，如果你尚未提交数据，还是可能丢失的，所以要养成定期提交数据到本地仓库或远程仓库的习惯。 Git的状态Git有三种状态，项目中已被跟踪的文件可能处于以下一种状态中：已提交(committed), 已修改(modified), 已暂存(staged)。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示文件已被修改，但还没提交到数据库中。 已暂存表示你已对某个修改过的文件的某个版本进行了标记，并会在下次提交时将其保存至快照中。由此引入Git的三个主要的工作区域的概念: 当前工作目录(working tree)，暂存区(staging area)，Git仓库(git directory)。 Git仓库是Git用来保存元数据和对象数据库的地方，这是Git最重要的部分，当你从其他地方克隆一个仓库时，拷贝的就是这里的数据。 当前工作目录存放你从项目的某个提交版本中checkout到本地磁盘的文件内容，也就是你通常使用和修改文件的地方。 暂存区域是一个文件，通常包含在你的Git仓库目录下，保存了你下次即将提交的内容信息。该区域的专业用词是“索引”，但称其为暂存区域也无不妥。 Git的基本工作流程如下: 在当前工作目录中修改文件 将文件的快照放入暂存区域 提交更新，将暂存区域中的文件快照永久性的存储到Git仓库中 文件的状态更准确的来说，Git项目中的文件状态可分为 未跟踪 和 已跟踪。而已被跟踪的文件的状态可分为：未修改，已修改 和 已暂存， 已提交。使用git status可以查看当前项目中的文件都处于哪些状态下如:123456$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.md 这表示在项目中有一个文件readme.md处于已修改的状态下且并未被放入暂存区域。","categories":[{"name":"Git","slug":"Git","permalink":"jaminchanks.github.io.git/categories/Git/"}],"tags":[]},{"title":"Java不高级特性:动态代理","slug":"Java/Java动态代理","date":"2018-05-21T15:44:51.291Z","updated":"2018-05-22T17:50:11.033Z","comments":true,"path":"2018/05/21/Java/Java动态代理/","link":"","permalink":"jaminchanks.github.io.git/2018/05/21/Java/Java动态代理/","excerpt":"吐槽变少了, 噢, 不! 生活还得继续，吐槽也是。 第一次真正对Java的动态代理感兴趣是因为Retrofit的关系。(大学学Spring时根本没深入到动态代理…)","text":"吐槽变少了, 噢, 不! 生活还得继续，吐槽也是。 第一次真正对Java的动态代理感兴趣是因为Retrofit的关系。(大学学Spring时根本没深入到动态代理…) 从Retrofit源码看动态代理 刚实习的时候第一次接触到Retrofit，然后去了它的官网逛了逛。 下面是来自官网的Retrofit基本用法:123456789101112public interface GitHubService &#123; @GET(\"users/&#123;user&#125;/repos\") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(\"user\") String user);&#125;Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .build();GitHubService service = retrofit.create(GitHubService.class);Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(\"octocat\"); 其中有一段代码格外引人注目：1GitHubService service = retrofit.create(GitHubService.class); 通过一个接口，然后就获得了一个类实例? ??, 对于当时还在实习的我来说，是这样子的。 不可否认。当时就只是觉得神奇而已。并没有下文。 后来，就闲着无聊去看它的源代码了。12345678910111213141516171819202122232425@SuppressWarnings(\"unchecked\") // Single-interface proxy creation guarded by parameter safety.public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; 在不讨论Retrofit的其他实现原理，单单只讨论create方法如何根据接口为我们实现具体类实例的情况下，我们把目光锁定到了Proxy.newProxyInstance(...)这个方法上。没错！这就是Java的 动态代理。 那么Proxy.newProxyInstance(...)这个方法具体是如何生成一个类实例的呢? 直接跳转到java源码中该方法的定义处，看看穿山甲都说了啥。 Returns an instance of a proxy class for the specified interfaces that dispatches method invocations to the specified invocation handler. 源码注释说得很清楚，通过这个方法可以返回指定接口的代理类，该代理类的方法调用会分发给指定的方法调用处理器。123public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 查看参数和返回值: ClassLoader loader: 加载该代理类的类加载器; Class&lt;?&gt;[] interfaces: 该代理类需要实现的接口; InvocationHandler h: 接口方法被调用时具体的处理程序,代理类的每一个方法被调用时都会由该处理程序处理; 返回值: 一个实现了指定接口的代理实例. 第一第二个参数不多解释，那么自然就要多讲下第三个参数: 第三个参数要求是一个实现了InvocationHandler接口的类,InvocationHandler接口的定义如下:12345public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 看看参数和返回值都是啥: Object proxy:具体调用方法的代理类实例(com.sun.proxy.$Proxy0实例); Method method:代理类需要实现的接口方法，该接口方法可能是某个接口的父接口方法，如果某个接口又继承自其他父接口的话; Object[] args:接口方法的参数; 返回值:接口方法的返回值。 依葫芦画瓢 我们也尝试着利用动态代理根据接口实现一个代理类。12345678910111213141516171819202122public class ProxyDemo &#123; public interface IFoo &#123; void sayHello(); &#125; public static class FooCreator&#123; @SuppressWarnings(\"unchecked\") static &lt;T&gt; T create(Class&lt;T&gt; clazz) &#123; return (T)Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]&#123;clazz&#125;, (proxy, method, args) -&gt; &#123; System.out.println(\"Hello\"); return null; &#125;); &#125; &#125; public static void main(String[] args) &#123; IFoo foo = FooCreator.create(IFoo.class); foo.sayHello(); &#125;&#125; 输出结果:1Hello 以上是由Retrofit中学到的动态代理的最基本应用，通过接口获得一个代理类实例。此外，动态代理还有一个作用,就是自己手动指定一个实现了接口的代理类，然后利用method.invoke()方法来调用自己指定的代理类方法。 举个例子:123456789101112131415161718192021222324252627282930public class ProxyDemo &#123; public interface IFoo &#123; void sayHello(); &#125; public static class FooImpl implements IFoo &#123; @Override public void sayHello() &#123; System.out.println(\"ByeBye\"); &#125; &#125; public static class FooCreator&#123; @SuppressWarnings(\"unchecked\") static &lt;T&gt; T create(Class&lt;T&gt; clazz) &#123; return (T)Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]&#123;clazz&#125;, (proxy, method, args) -&gt; &#123; System.out.println(\"你好，我是乱入的，请忽略我\"); IFoo foo = new FooImpl(); return method.invoke(foo, args); &#125;); &#125; &#125; public static void main(String[] args) &#123; IFoo foo = FooCreator.create(IFoo.class); foo.sayHello(); &#125;&#125; 代理类的方法在调用的时候，都委托给了FooImpl类，让它来处理每个方法的具体调用，在方法调用的前后还可以随意插入代码片段，比如上面的代码中就跑进了奇怪的东西。 12你好，我是乱入的，请忽略我ByeBye 总结 总结下动态代理的主要应用场景: 1. 通过动态代理可以实现通过接口直接获取到代理类实例，而不需要手动去编写对应接口的实现类，这对于减少项目中的代码量有一定的用处； 2. 实现与静态代理一样的功能，在方法调用处理器中指定对应的接口实现类，然后调用其对应的方法; 3. 在不修改源码的情况下，在方法被执行的前后添加一些自定义的行为。比如上面例子中的代码乱入。 那么，接下来有个疑问：如果这个篇章就这么结束了，那也太水了吧。 是的，没错，就是这么水。 难道要继续深入分析Retrofit的实现或是逐步深入分析Proxy.newProxyInstance的实现?","categories":[{"name":"Java","slug":"Java","permalink":"jaminchanks.github.io.git/categories/Java/"}],"tags":[]},{"title":"从原理分析和区分lateinit var、by lazy","slug":"Kotlin/Koltin的byLazy实现原理","date":"2018-05-12T07:12:08.120Z","updated":"2018-05-22T17:14:01.233Z","comments":true,"path":"2018/05/12/Kotlin/Koltin的byLazy实现原理/","link":"","permalink":"jaminchanks.github.io.git/2018/05/12/Kotlin/Koltin的byLazy实现原理/","excerpt":"Koltin中属性在声明的同时也要求要被初始化，否则会报错。","text":"Koltin中属性在声明的同时也要求要被初始化，否则会报错。 123private var name0: String //报错private var name1: String = &quot;xiaoming&quot; //不报错private var name2: String? = null //不报错 可是有的时候，我并不想声明一个类型可空的对象，而且我也没办法在对象一声明的时候就为它初始化，那么这时就需要用到Kotlin提供的延迟初始化。 Kotlin中有两种延迟初始化的方式。一种是lateinit var，一种是by lazy。 lateinit var1private lateinit var name: String lateinit var只能用来修饰类属性，不能用来修饰局部变量，并且只能用来修饰对象，不能用来修饰基本类型(因为基本类型的属性在类加载后的准备阶段都会被初始化为默认值)。 lateinit var的作用也比较简单，就是让编译期在检查时不要因为属性变量未被初始化而报错。 Kotlin相信当开发者显式使用lateinit var 关键字的时候，他一定也会在后面某个合理的时机将该属性对象初始化的(然而，谁知道呢，也许他用完才想起还没初始化)。 by lazy by lazy本身是一种属性委托。属性委托的关键字是by。by lazy 的写法如下：12345678//用于属性延迟初始化val name: Int by lazy &#123; 1 &#125;//用于局部变量延迟初始化public fun foo() &#123; val bar by lazy &#123; \"hello\" &#125; println(bar)&#125; 以下以name属性为代表来讲解by kazy的原理，局部变量的初始化也是一样的原理。 by lazy要求属性声明为val，即不可变变量，在java中相当于被final修饰。 这意味着该变量一旦初始化后就不允许再被修改值了(基本类型是值不能被修改，对象类型是引用不能被修改)。{}内的操作就是返回唯一一次初始化的结果。 by lazy可以使用于类属性或者局部变量。 写一段最简单的代码分析by lazy的实现:123456789class TestCase &#123; private val name: Int by lazy &#123; 1 &#125; fun printname() &#123; println(name) &#125;&#125; 在IDEA中点击toolbar中的 Tools -&gt; Kotlin -&gt; Show Kotlin ByteCode， 查看编辑器右侧的工具栏: 不想看字节码分析的可以直接跳过，每段字节码后面都有java/kotlin版本的解释 更完整的字节码片段如下:1234567891011121314151617public &lt;init&gt;()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V L1 LINENUMBER 5 L1 ALOAD 0 GETSTATIC com/rhythm7/bylazy/TestCase$name$2.INSTANCE : Lcom/rhythm7/bylazy/TestCase$name$2; CHECKCAST kotlin/jvm/functions/Function0 INVOKESTATIC kotlin/LazyKt.lazy (Lkotlin/jvm/functions/Function0;)Lkotlin/Lazy; PUTname com/rhythm7/bylazy/TestCase.name$delegate : Lkotlin/Lazy; RETURN L2 LOCALVARIABLE this Lcom/rhythm7/bylazy/TestCase; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 该段代码是在字节码生成的public &lt;clinit&gt;()V 方法内的。之所以是在该方法内，是因为非单例object的Kotlin类的属性初始化代码语句经过编译器处理后都会被收集到该方法内，如果是object对象，对应的属性初始化代码语句则会被收集到static &lt;clinit&gt;()V方法中。另外，在字节码中，这两个方法是拥有不同方法签名的，这与语言级别上判断两个方法是否相同的方式有所不同。前者是实例构造方法，后者是类构造方法。 L0与L1之间的字节码代表调用了Object()的构造方法，这是默认的父类构造方法。L2之后的是本地变量表说明。L1与L2之间的字节码对应如下kotlin代码：1private val name: Int by lazy &#123; 1 &#125; L1与L2之间这段字节码的意思是:源代码行号5对应字节码方法体内的行号1；将this(非静态方法默认的第一个本地变量)推送至栈顶;获取静态变量com.rhythm7.bylazy.TestCase$name$2.INSTANCE;检验INSTANCE能否转换为kotlin.jvm.functions.Function0类;调用静态方法kotlin.LazyKt.lazy(kotlin.jvm.functions.Function0)，将INSTANCE作为参数传入，并获得一个kotlin.Lazy类型的返回值;将以上返回值赋值给com.rhythm7.bylazy.TestCase.name$delegate;最后结束方法。 相当于java代码:123TestCase() &#123; name$delegate = LazyKt.lazy((Function0)name$2.INSTANCE)&#125; 其中name$delegate是编译后生成的属性，对象类型为Lazy。1private final Lkotlin/Lazy; name$delegate name$2都是编译后生成的内部类。1final class com/rhythm7/bylazy/TestCase$name$2 extends kotlin/jvm/internal/Lambda implements kotlin/jvm/functions/Function0 name$2继承了kotlin.jvm.internal.Lambda类并实现了kotlin.jvm.functions.Function0接口，可以看出name$2其实就是kotlin函数参数类型()-&gt;T的具体实现，通过字节码分析不难知道name$2.INSTANCE则是该实现类的一个静态对象实例。所以以上字节码又相当于Koltin中的:123init &#123; name$delegate = lazy(()-&gt;&#123;&#125;)&#125; 然而，这些代码的作用仅仅是给一个编译期生成的属性变量赋值而已，并没有其他的操作。 真正实现属性变量延迟初始化的地方其实是在属性name的getter方法里。 如果在java代码中调用过kotlin代码，会发现java代码中只能通过setter或getter的方式访问koltin编写的对象属性，这是因为kotlin中默认会对属性添加private修饰符，并根据该属性变量是val还是var生成getter或getter和setter一起生成。然后又根据对该属性的访问权限给getter和setter添加对应的访问权限修饰符(默认是public)。 查看getName()的具体实现:12345678910111213141516171819202122private final getName()I L0 ALOAD 0 GETFIELD com/rhythm7/bylazy/TestCase.name$delegate : Lkotlin/Lazy; ASTORE 1 ALOAD 0 ASTORE 2 GETSTATIC com/rhythm7/bylazy/TestCase.$$delegatedProperties : [Lkotlin/reflect/KProperty; ICONST_0 AALOAD ASTORE 3 L1 ALOAD 1 INVOKEINTERFACE kotlin/Lazy.getValue ()Ljava/lang/Object; L2 CHECKCAST java/lang/Number INVOKEVIRTUAL java/lang/Number.intValue ()I IRETURN L3 LOCALVARIABLE this Lcom/rhythm7/bylazy/TestCase; L0 L3 0 MAXSTACK = 2 MAXLOCALS = 4 相当于java代码: 12345private final int getName()&#123; Lazy var1 = this.name$delegate; KProperty var2 = this.$$delegatedProperties[0] return ((Number)var1.getValue()).intValue()&#125; 可以看到name的getter方法其实是返回了 name$delegate.getValue()方法。$$delegatedProperties是编译后自动生成的属性，但在此处并没有用到，所以不用关心。 那么现在我们要关心的就只有name$delegate.getValue()，也就是Lazy类getValue()方法的具体实现了。 先看LazyKt.lazy(()-&gt;T)的实现:1public fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer) 再看SynchronizedLazyImpl类的具体实现: 1234567891011121314151617181920212223242526272829303132private object UNINITIALIZED_VALUEprivate class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable &#123; private var initializer: (() -&gt; T)? = initializer @Volatile private var _value: Any? = UNINITIALIZED_VALUE // final field is required to enable safe publication of constructed instance private val lock = lock ?: this override val value: T get() &#123; val _v1 = _value if (_v1 !== UNINITIALIZED_VALUE) &#123; @Suppress(\"UNCHECKED_CAST\") return _v1 as T &#125; return synchronized(lock) &#123; val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) &#123; @Suppress(\"UNCHECKED_CAST\") (_v2 as T) &#125; else &#123; val typedValue = initializer!!() _value = typedValue initializer = null typedValue &#125; &#125; &#125;......&#125; 以上代码的阅读难度就非常低了。 SynchronizedLazyImpl继承了Lazy类，并指定了泛型类型，然后重写了Lazy父类的getValue()方法。getValue()方法中会对_value是否已初始化做判断，并返回_value，从而实现value的延迟初始化的作用。对value的初始化本身是线程安全的。 总结 总结一下，当一个属性name需要by lazy时，具体是怎么实现的：1.生成一个该属性的附加属性:name$$delegate；2.在构造器中，将使用lazy(()-&gt;T)创建的Lazy实例对象赋值给name$$delegate；3.当该属性被调用，即其getter方法被调用时返回name$$delegate.getVaule()，而name$$delegate.getVaule()方法的返回结果是对象name$$delegate内部的_value属性值，在getVaule()第一次被调用时会将_value进行初始化，往后都是直接将_value的值返回，从而实现属性值的唯一一次初始化。 那么，再总结一下，lateinit var和by lazy哪个更好用? 首先两者的应用场景是略有不同的。 然后，虽然两者都可以推迟属性初始化的时间，但是lateinit var只是让编译期忽略对属性未初始化的检查，后续在哪里以及何时初始化还需要开发者自己决定。 而by lazy真正做到了声明的同时也指定了延迟初始化时的行为，在属性被第一次被使用的时候能自动初始化。但这些功能是要为此付出一些代价的。","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"jaminchanks.github.io.git/categories/Kotlin/"}],"tags":[]},{"title":"Java对象内存分配，堆还是栈? 这是个问题","slug":"Java/堆还是栈","date":"2018-04-30T03:31:28.526Z","updated":"2018-04-30T16:40:12.658Z","comments":true,"path":"2018/04/30/Java/堆还是栈/","link":"","permalink":"jaminchanks.github.io.git/2018/04/30/Java/堆还是栈/","excerpt":"在说java的对象分配内存所在位置前，我们先来看看C++的对象分配是怎样的。C++实例化对象的方式有两种：","text":"在说java的对象分配内存所在位置前，我们先来看看C++的对象分配是怎样的。C++实例化对象的方式有两种： 直接定义对象，对象被分配在方法栈的本地变量栈上，生命周期与方法栈一致，方法退出时对象被自动销毁。 通过new关键字在堆上分配对象，对象要用户手动销毁。 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;class ClassA &#123;private: int arg;public: explicit ClassA(int a): arg(a) &#123; cout &lt;&lt; \"ClassA(\" &lt;&lt; arg &lt;&lt; \")\" &lt;&lt; endl; &#125; ~ClassA()&#123; cout &lt;&lt; \"~ClassA(\" &lt;&lt; arg &lt;&lt; \")\" &lt;&lt; endl; &#125;&#125;;int main() &#123; ClassA ca1(1); //直接定义对象 ClassA* ca2 = new ClassA(2); //使用new关键字 return 0;&#125; 输出结果:123ClassA(1)ClassA(2)~ClassA(1) 直接定义对象的方式会将对象内存分配在栈上，因此main函数退出后会执行ClassA的虚构函数，该对象被回收。而使用new实例化的对象内存分配在堆上，对象在main函数退出后不会执行虚构函数。 C++中，内存可以被分配到栈上或者堆内存中。 那么java是否也是这样呢，如果java在必要的时候也是把对象分配到栈上，从而自动销毁对象，那必然能减少一些垃圾回收的开销(java的垃圾回收需要进行标记整理等一系列耗时操作)，同时也能提高执行效率(栈上存储的数据有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储)。虽然，这些细节都是针对JVM而言的，对于开发者而言似乎不太需要关心。然而，我还是好奇。 写一段不怎么靠谱的代码来观察Java的输出结果:1234567891011121314151617181920212223242526272829303132333435public class ClassA&#123; public int arg; public ClassA(int arg) &#123; this.arg = arg; &#125; @Override protected void finalize() throws Throwable &#123; System.out.println(\"对象即将被销毁: \" + this + \"; arg = \" + arg); super.finalize(); &#125; &#125; public class TestCase1 &#123; public static ClassA getClassA(int arg) &#123; ClassA a = new ClassA(arg); System.out.println(\"getA() 方法内:\" + a); return a; &#125; public static void foo() &#123; ClassA a = new ClassA(2); System.out.println(\"foo() 方法内:\" + a); &#125; public static void main(String[] args) &#123; ClassA classA = getClassA(1); System.out.println(\"main() 方法内:\" + classA); foo(); &#125; &#125; 输出结果:123getA() 方法内:com.rhythm7.A@29453f44main() 方法内:com.rhythm7.A@29453f44foo() 方法内:com.rhythm7.A@5cad8086 执行完getA()方法后，getA()方法内实例化的classA对象实例a被返回并赋值给main方法内的classA (此时使用的是引用传递，所以最后的输出结果是相同的HashCode)。接着执行foo()方法，方法内部实例化一个classA对象，但只是输出其HashCode，没有返回其对象。 结果是两个对象都没有执行finalize()方法。 如果我们强制使用System.gc()来通知系统进行垃圾回收，结果如何?123456public static void main(String[] args) &#123; A a = getA(1); System.out.println(\"main() 方法内:\" + a); foo(); System.gc();&#125; 输出结果1234getA() 方法内:com.rhythm7.A@29453f44main() 方法内:com.rhythm7.A@29453f44foo() 方法内:com.rhythm7.A@5cad8086对象即将被销毁: com.rhythm7.A@5cad8086; arg = 2 这说明，需要通知垃圾回收器进行进行垃圾回收才能回收方法foo()内实例化的对象。所以，可以肯定foo()内实例化的对象不会跟随foo()方法的出栈而销毁，也就是foo()方法内实例化的局部对象不会是分配在栈上的。 查阅相关资料，发现JVM的确存在一个 “逃逸分析” 的概念。内容大概如下： 逃逸分析是目前Java虚拟机中比较前沿的优化技术，它并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。逃逸分析的主要作用就是分析对象作用域。 当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种行为就叫做 方法逃逸。甚至该对象还可能被外部线程访问到，例如赋值被类变量或可以在其他线程中访问的实例变量，称为 线程逃逸。 通过逃逸分析技术可以判断一个对象不会逃逸到方法或者线程之外。根据这一特点，就可以让这个对象在栈上分配内存，对象所占用的内存空间就可以随帧栈出栈而销毁。在一般应用中，不会逃逸的局部对象所占比例很大，如果能使用栈上分配，那么大量的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力就会小很多。 除此之外，逃逸分析的作用还包括 标量替换 和 同步消除 ; 标量替换 指：若一个对象被证明不会被外部访问，并且这个对象可以被拆解成若干个基本类型的形式，那么当程序真正执行的时候可以不创建这个对象，而是采用直接创建它的若干个被这个方法所使用到的成员变量来代替，将对象拆分后，除了可以让对象的成员变量在栈上分配和读写之外，还可以为后续进一步的优化手段创造条件。 同步消除 指：若一个变量被证明不会逃逸出线程，那么这个变量的读写就肯定不会出现竞争的情况，那么对这个变量实施的同步措施也就可以消除掉。说了逃逸分析的这些作用，那么Java虚拟机是否有对对象做逃逸分析呢? 答案是否。 关于逃逸分析的论文在1999年就已经发表，但直到Sun JDK 1.6才实现了逃逸分析，而且直到现在这项优化尚未足够成熟，仍有很大的改进余地。不成熟的原因主要是不能保证逃逸分析的性能收益必定高于它的消耗。因为逃逸分析本身就是一个高耗时的过程，假如分析的结果是没有几个不逃逸的对象，那么这个分析所花费时候比优化所减少的时间更长，这是得不偿失的。 所以目前虚拟机只能采用不那么准确，但时间压力相对较小的算法来完成逃逸分析。还有一点是，基于逃逸分析的一些优化手段，如上面提到的“栈上分配”，由于HotSpot虚拟机目前的实现方式导致栈上分配实现起来比较复杂，因此在HotSpot中暂时还没有做这项优化。事实上，在java虚拟机中，有一句话是这么写的: The heap is the runtime data area from which memory for all class instances and arrays is allocated。堆是所有的对象实例以及数组分配内存的运行时数据区域。 所以，忘掉Java栈上分配对象的想法吧，至少在目前的HotSpot中是不存在的。也就是说Java的对象分配只在堆上。 ps:如果有需要，并且确认对程序运行有益，用户可以使用参数-XX:+DoEscapeAnalysis来手动开启逃逸分析，开启之后可以通过参数-XX:+PrintEscapeAnalysis来查看分析结果。","categories":[{"name":"Java","slug":"Java","permalink":"jaminchanks.github.io.git/categories/Java/"}],"tags":[]},{"title":"数据结构复习笔记(待补充)","slug":"Read/算法的实际用处","date":"2018-04-24T14:58:14.464Z","updated":"2018-05-12T16:32:34.508Z","comments":true,"path":"2018/04/24/Read/算法的实际用处/","link":"","permalink":"jaminchanks.github.io.git/2018/04/24/Read/算法的实际用处/","excerpt":"如果大脑也能固件升级,而且不贵,该多好… 这个星期，不知不觉看了两本技术书籍。一本《Android Gradle权威指南》,一本《算法图解》。第一本页数200多页，但内容近乎乏善可陈，第二本400多页(电子书)，但图片很多，阅读起来饶有趣味。因为两本书都不是在零基础的情况下阅读的，一开始就本着查漏补缺的态度，但阅读过后还是觉得有必要记录一下读书笔记。 所以主要说说算法图解这本书中的一些东西。","text":"如果大脑也能固件升级,而且不贵,该多好… 这个星期，不知不觉看了两本技术书籍。一本《Android Gradle权威指南》,一本《算法图解》。第一本页数200多页，但内容近乎乏善可陈，第二本400多页(电子书)，但图片很多，阅读起来饶有趣味。因为两本书都不是在零基础的情况下阅读的，一开始就本着查漏补缺的态度，但阅读过后还是觉得有必要记录一下读书笔记。 所以主要说说算法图解这本书中的一些东西。 一、时间复杂度常见时间复杂度与其对应的算法： O(log n): 对数时间，常见的算法包括二分查找 O(n): 线性时间，常见的如简单查找 O(n * log n): 常见如快速排序算法，归并排序等(总体上来讲，快速排序是优于归并排序的，思考为什么) O(n ^ 2)：常见如冒泡排序，选择排序等 O(n!)：阶乘时间，常见如 旅行商问题 的最优解算法 简单介绍下旅行商问题: 假如现在有一个旅行商想要前往这5个城市(每两个城市间的往返路线不一定相同)，同时要确保旅程最短并最终返回出发城市。那么就需要考虑前往这些城市的所有可能顺序，比如： 马林 -&gt; 旧金山 -&gt; 帕洛阿尔托 -&gt; 弗里蒙特 -&gt; 伯克利 -&gt; 马林 马林 -&gt; 伯克利 -&gt; 弗里蒙特 -&gt; 帕洛阿尔托 -&gt; 旧金山 -&gt; 马林 帕洛阿尔托 -&gt; 弗里蒙特 -&gt; 伯克利 -&gt; 马林 -&gt; 旧金山 -&gt; 帕洛阿尔托 等等…… 当前有5个城市，每条可能的路线首尾是相同的，那么就有5! = 120个可能顺序，如果再多加一个城市,则可能的排序会增加至6! = 720种。对于这种旅行商问题的最优解的算法目前还没有，但是可以通过动态规划求得近似的最优解。 二、数组与链表 数组使用的是连续的内存空间;链表使用的是非连续的内存空间; 数组支持随机读取，所以读取速度很快，时间复杂度为O(1);链表不支持随机读取，读取时间复杂度为O(n); 数组的插入和删除速度较慢，每次操作都需要挪动被操作元素位置之后的所有元素链表的插入和删除速度很快，只需对操作被操作元素及其前后位置的元素即可 三、递归 递归指在函数的定义中调用函数自身的方法。 递归需要 基线条件 (终止条件)和 递归条件 。 使用递归可能导致函数调用栈太深，从而占用大量内存甚至导致StackOverflow和OutOfMemory。 递归函数的优化方式有:(1) 使用循环代替递归;(2) 使用尾递归(尾递归会被一些语言的编译器所优化，比如帧栈变量的复用等，但并非所有语言都支持该特性); 一种常见的递归思想解决的算法，比如分治法 ：即分而治之，把一个复杂的问题分解成两个或更多个相同或者相似的字问题，直到最后每个子问题都可以通过简单的方式直接求解，再将所有子问题的解合并，合并的结果就是该问题的解。分治法是很多高效算法的基础，如排序算法（快速排序、归并排序）、傅立叶变换（快速傅立叶变换）。 四、散列函数散列函数（Hash function）又称散列算法、哈希函数。散列函数的作用是为任何一种数据创建数字“指纹”(散列值)，从而实现从输入到运算结果的映射。一般而言，数字指纹的大小要比原数据小得多。反过来，通过判断两个数字指纹是否相同，可以判断出两个指纹的原始数据是否相同，但无法还原出原数据。在散列函数中，有可能出现散列碰撞，即不同数据出现相同数字指纹的可能性，但对于一个设计良好的散列函数来说是很少出现散列碰撞的。 1. 避免散列碰撞的主要方式有: (1) 较低的填装因子 散列函数的输入和输入对应的是一种映射关系，我们将此理解为一个萝卜一个坑的简单原理。比如我们通过散列函数的计算，将输入存放在散列表中的唯一对应位置。根据散列表总位置数和已有元素个数可计算出填装因子。 填装因子 = 散列表包含的元素个数 / 散列表的位置总数 填装因子越低，发生散列碰撞的可能性就越低，为了避免碰撞的存在，在填装因子达到一定大小的时候，就需要对整个散列表的位置总数进行扩容。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的位置总数。 (2) 良好的散列函数 比如SHA系列算法就是不错的散列函数算法，目前SHA-0和SHA-1已被发现存在一些缺陷，因此推荐SHA-2和SHA-3算法。 2. 散列函数的主要应用场景有:(1) 通过散列函数可以实现按照关键字快速查找数据(字典)；(2) 比较文件是否相同，散列函数的输出要比原文件的数据小得多；(3) 在数据库中存储非明文数据，然后通过检查散列值的方式对比数据，如密码检验等；(4) SHA是非局部敏感的，这意味着，哪怕修改源输入的一点点内容，输出结果都大不相同，因而无法比较源输入的相似性，比较相似性可以使用 Simhash算法。(5) 其他。 五、树六、图七、迪杰斯特拉算法(Dijkstra’s algorithm)计算非加权图的最短路径可以用广度优先搜索算法。如果要计算加权图(不包含负权重)的最短路径，需要使用迪杰斯特拉算法。迪杰斯特拉算法的主要步骤有：(1)从某个节点出发(2)如果当前节点没有邻居，跳至步骤(5), 或所有邻居节点都执行过步骤(4)，跳到步骤(6), 否则计算前往所有未执行过步骤(4)的邻居的开销(3)如果某个邻居节点先前没有记录，添加开销和所经路径(或先前节点)记录，如果已有记录并发现有从最初起始点到该邻居的更小开销，刷新开销和所经路径(或先前节点)记录(4)按从最初起始点到下个邻居节点所需开销从小到大的顺序，依次以下个邻居节点作为出发点出发， 重复(1)(5)结束当前节点，开始下个节点，重复(1)(6)算法结束 假如每个顶点代表一个城市，边长代表距离，求从a城市出发，达到其它各个城市的最短距离和最短路径分别是什么。 八、贪婪算法九、近似算法十、动态规划十一、线性规划十二、K最邻算法十三、费曼算法费曼算法是以著名物理学家查德-费曼命名的，主要实现步骤如下: 将问题写下来 好好思考 将答案写下来 十四、补充反向索引傅立叶变换归一化","categories":[{"name":"Read","slug":"Read","permalink":"jaminchanks.github.io.git/categories/Read/"}],"tags":[]},{"title":"《深入理解Java虚拟机》学习笔记2","slug":"Java/JVM原理2","date":"2018-04-16T15:23:39.354Z","updated":"2018-04-30T13:03:49.777Z","comments":true,"path":"2018/04/16/Java/JVM原理2/","link":"","permalink":"jaminchanks.github.io.git/2018/04/16/Java/JVM原理2/","excerpt":"剩余的那几天什么都不想干…","text":"剩余的那几天什么都不想干… 虚拟机类加载机制虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。因为Java类型的加载、连接和初始化过程都是在程序运行期间完成的，所以java程序拥有高度的灵活性。比如我们在编写一个面向接口的应用程序时，可以等到程序运行时再指定其实际的实现类。又或者，用户可以通过Java预定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或者其他地方加载一个二进制流作为程序代码的一部分。 1. 类的生命周期一个类从被加载到虚拟机的内存中，到被卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用 和 卸载。其中验证，准备和解析3部分统称为 连接(Linking)。 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，而解析阶段则不一定，它可以在初始化阶段之后才开始。 2. 需要加载类的时机(1) 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先出发其初始化。生成这4条指令的最常见的Java代码场景为：使用new关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外,因为这种情况下调用类不会直接引用到定义常量的类)的时候，以及调用一个类的静态方法的时候。(2)使用java.lang.relect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。(3)当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先出发其父类的初始化。(4)当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的主类)，虚拟机会先初始化这个主类。(5)当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 3. 加载在加载阶段，虚拟机需要完成以下3件事情：(1)通过一个类的全限定名来获取定义此类的二进制字节流。(2)将这个字节流的静态存储结构转化为方法区的运行时数据结构。(3)在内存中生存一个代表这个类的java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但数组中的数组元素最终还是由类加载器去创建。 4. 验证验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 5. 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。值得注意的是，这里进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。 1public static int value = 123; 以上代码在准备阶段过后会将value赋初始值为0。赋值为123的操作在后续的初始化阶段。 6. 解析解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程，关于符号引用在之前的文章中多少都有介绍到。 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。 7. 初始化类初始化阶段是类加载过程的最后一步。到了初始化阶段，才真正执行类中定义的java程序代码(字节码)。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。或者从另外一个角度来表达：初始化阶段是执行类构造器 &lt; clinit &gt;()方法的过程。&lt; clinit &gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在原文件中出现的顺序所决定的。虚拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确的枷锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类&lt; clinit &gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit &gt;()方法完毕。 8. 类加载器类加载器只用于实现类的加载动作。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，只有同一个类加载器加载的两个类才有可能”相等”。 9. 双亲委派模型双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 也许此处也应有图片补充…ps：JVM的多线程模型暂时不做记录。","categories":[{"name":"Java","slug":"Java","permalink":"jaminchanks.github.io.git/categories/Java/"}],"tags":[]},{"title":"《深入理解Java虚拟机》学习笔记1","slug":"Java/JVM原理1","date":"2018-04-15T15:11:51.930Z","updated":"2018-04-30T14:03:18.425Z","comments":true,"path":"2018/04/15/Java/JVM原理1/","link":"","permalink":"jaminchanks.github.io.git/2018/04/15/Java/JVM原理1/","excerpt":"不知道为什么，一个月总有那么20几天只想思考人生…","text":"不知道为什么，一个月总有那么20几天只想思考人生… 一、运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。 1. 程序计数器程序计数器是一块比较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器(对于多喝处理器来说是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立储存，我么称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Native方法，这个计数器值则为Undefined。 2. Java虚拟机栈虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个帧栈，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个帧栈在虚拟机栈中入栈到处栈的过程。一般会有人将java内存区简单的分为堆内存(Heap)和栈内存(Stack)。当这么区分时，栈内存一般指虚拟机栈中局部变量表的部分。局部变量表所需的内存空间在编译期完成分配并已确定，在方法运行期间不会改变。在Java虚拟机规范中，对这个区域定义了两种异常情况: 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常 如果虚拟机可以动态扩展且扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常 3. 本地方法栈本地方法栈与虚拟机栈基本类似，但本地方法栈是虚拟机使用到的Navtive方法服务。 4. Java堆对于大多数应用来讲，Java堆(Java Heap)是Java虚拟机所管理的内存最大的一块，Java堆是被所有线程共享的一块区域，在虚拟机启动的时候创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。(可以通过-Xmx和-Xms来扩展堆大小) 5. 方法区方法区和Java堆一样，是各个线程共享的内存区域，Java虚拟机把方法区描述为堆的一个逻辑部分，但它还有一个别名Non-Heap，其目的是为了与堆区分开来。方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。 6. 运行时常量池运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 7. 直接内存直接内存并不是虚拟机运行时数据区的一部分。 二、 对象的生命周期1. 对象的创建当Java虚拟机遇到一条new指令时，首先将去检查这条指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就执行相对用的类加载过程。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后变可完全确定。 2. 对象的内存布局在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data) 和 对齐填充(Padding) 对象头用于存储对象自身的运行时数据，如哈希码(HashCode)，GC分代年龄、锁标志状态、线程持有的锁、偏向线程ID、偏向时间戳等，还有就是类型指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例税局部分是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。 对齐填充，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以对象的大小必须是8字节的整数倍。 3. 对象的访问定位Java程序需要通过栈上的Reference数据来操作堆上的具体对象，而Reference类型在Java虚拟机中只有一个指向对象的引用。从Reference到获取到具体的对象的访问方式有两种，一种是 使用句柄，一种是 直接指针。 使用句柄访问的话，Java堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。好处是当对象被移动时，只会改变句柄汇总的实例数据指针，reference无需改变，坏处是较直接指针大。 使用直接指针访问，则reference中存储的是到对象类型数据的指针，通过它可以直接访问到实例对象。HotSpot使用的是直接指针访问的方式。 4. 对象引用分析算法判断对象是否应该回收主要有两种算法： (1). 引用计数算法给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减一。任何时刻计数器为0的对象都是不可能再被使用的。该算法实现简单，但很难解决对象间的相互循环引用的问题。 (2). 可达性分析算法该算法的基本思路是通过一系列被称为”GC Roots”的对象作为起点，从这些节点开始往下搜索，搜索所走过的路径被称为 引用链，当一个对象到GC Roots没有任何引用链相连，也就是从GC Roots到该对象不可达时，则证明该对象是不可用的。 此处应有图片补充… 在Java语言中，可作为GC Roots的对象包括以下几种: 虚拟机栈(帧栈中的本地变量表)中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈JNI(即一般说的Native方法)引用的对象 5. 引用强弱在Java中，引用可分为 强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)。这4种引用强度依次递减。 一般被直接new出来的对象都是强引用 软引用被用来描述一些还有用但并非必须的对象，在系统将要发生内存溢出异常之前会把弱引用关联的对象列进回收范围之中进行第二次回收。使用SoftReference类来使用弱引用。 弱引用所关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都睡回收掉只被弱引用关联的对象。使用WeakReference来来使用弱引用。 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象实例，但是虚引用所关联的对象在被回收时可以收到一个系统通知。使用PhantomReference类来使用虚引用。 6. 生存还是死亡 —— 对象的自我拯救？即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。从代码清单3-2中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。 ps：对象回收过程以及对应算法本文不做记录，下篇文章是记录虚拟机类加载机制的笔记。","categories":[{"name":"Java","slug":"Java","permalink":"jaminchanks.github.io.git/categories/Java/"}],"tags":[]},{"title":"看懂Java字节码","slug":"Java/Java字节码1","date":"2018-04-07T07:14:10.399Z","updated":"2018-04-16T15:28:48.662Z","comments":true,"path":"2018/04/07/Java/Java字节码1/","link":"","permalink":"jaminchanks.github.io.git/2018/04/07/Java/Java字节码1/","excerpt":"java字节码计算机只认识0和1。这意味着任何语言编写的程序最终都需要经过编译器编译成机器码才能被计算机执行。所以，我们所编写的程序在不同的平台上运行前都要经过重新编译才能被执行。而Java刚诞生的时候曾经提过一个非常著名的宣传口号: “一次编写，到处运行”。","text":"java字节码计算机只认识0和1。这意味着任何语言编写的程序最终都需要经过编译器编译成机器码才能被计算机执行。所以，我们所编写的程序在不同的平台上运行前都要经过重新编译才能被执行。而Java刚诞生的时候曾经提过一个非常著名的宣传口号: “一次编写，到处运行”。 Write Once, Run Anywhere. 为了实现该目的，Sun公司以及其他虚拟机提供商发布了许多可以运行在不同平台上的JVM虚拟机，而这些虚拟机都拥有一个共同的功能，那就是可以载入和执行同一种与平台无关的字节码(ByteCode)。于是，我们的源代码不再必须根据不同平台翻译成0和1，而是间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。如今，JVM也不再只支持Java，由此衍生出了许多基于JVM的编程语言，如Groovy, Scala, Koltin等等。 一个Java的程序员不需要知道或了解Java字节码的。但是，正如IBM developerWorks杂志中所建议的，“了解字节码和Java编译器可能生成的字节码可以帮助Java程序员以与装配知识相同的方式帮助C或C ++程序员。 –wikipedia 源代码中的各种变量，关键字和运算符号的语义最终都会编译成多条字节码命令。而字节码命令所能提供的语义描述能力是要明显强于Java本身的，所以有其他一些同样基于JVM的语言能提供许多Java所不支持的语言特性。 例子下面以一个例子来逐步讲解字节码。123456789//Main.javapublic class Main &#123; private int m; public int inc() &#123; return m + 1; &#125;&#125; 通过以下命令, 可以在当前所在路径下生成一个Main.class文件。1javac Main.java 以文本的形式打开生成的class文件，内容如下:123456789101112131415161718cafe babe 0000 0034 0013 0a00 0400 0f090003 0010 0700 1107 0012 0100 016d 01000149 0100 063c 696e 6974 3e01 0003 28295601 0004 436f 6465 0100 0f4c 696e 654e756d 6265 7254 6162 6c65 0100 0369 6e630100 0328 2949 0100 0a53 6f75 7263 6546696c 6501 0009 4d61 696e 2e6a 6176 610c0007 0008 0c00 0500 0601 0010 636f 6d2f7268 7974 686d 372f 4d61 696e 0100 106a6176 612f 6c61 6e67 2f4f 626a 6563 74002100 0300 0400 0000 0100 0200 0500 06000000 0200 0100 0700 0800 0100 0900 00001d00 0100 0100 0000 052a b700 01b1 00000001 000a 0000 0006 0001 0000 0003 0001000b 000c 0001 0009 0000 001f 0002 00010000 0007 2ab4 0002 0460 ac00 0000 01000a00 0000 0600 0100 0000 0800 0100 0d000000 0200 0e 对于文件中的16进制代码，除了开头的cafe babe，剩下的内容大致可以翻译成:啥玩意啊这是…… 英雄莫慌，我们就从我们所能认识的”cafe babe”讲起吧。文件开头的4个字节称之为 魔数，唯有以”cafe babe”开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。目光右移，0000是编译器jdk版本的次版本号0，0034转化为十进制是52,是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外,以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0。通过java -version命令稍加验证, 可得结果。12Java(TM) SE Runtime Environment (build 1.8.0_131-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode) 结果验证成立。 继续往下是常量池。但我并不打算继续直接分析这个十六进制文件。 反编译字节码文件使用到java内置的一个反编译工具javap可以反编译字节码文件。通过javap -help可了解javap的基本用法12345678910111213141516171819用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括: -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类 和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath &lt;path&gt; 指定查找用户类文件的位置 -cp &lt;path&gt; 指定查找用户类文件的位置 -bootclasspath &lt;path&gt; 覆盖引导类文件的位置 输入命令javap -verbose -p Main.class查看输出内容: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/Main.class Last modified 2018-4-7; size 362 bytes MD5 checksum 4aed8540b098992663b7ba08c65312de Compiled from \"Main.java\"public class com.rhythm7.Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#18 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Fieldref #3.#19 // com/rhythm7/Main.m:I #3 = Class #20 // com/rhythm7/Main #4 = Class #21 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/rhythm7/Main; #14 = Utf8 inc #15 = Utf8 ()I #16 = Utf8 SourceFile #17 = Utf8 Main.java #18 = NameAndType #7:#8 // \"&lt;init&gt;\":()V #19 = NameAndType #5:#6 // m:I #20 = Utf8 com/rhythm7/Main #21 = Utf8 java/lang/Object&#123; private int m; descriptor: I flags: ACC_PRIVATE public com.rhythm7.Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/rhythm7/Main; public int inc(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 8: 0 LocalVariableTable: Start Length Slot Name Signature 0 7 0 this Lcom/rhythm7/Main;&#125;SourceFile: \"Main.java\" 字节码文件信息开头的7行信息包括:Class文件当前所在位置，最后修改时间，文件大小，MD5值，编译自哪个文件，类的全限定名，jdk次版本号，主版本号。然后紧接着的是该类的访问标志：ACC_PUBLIC, ACC_SUPER，访问标志的含义如下: 标志名称 标志值 含义 ACC_PUBLIC 0x0001 是否为Public类型 ACC_FINAL 0x0010 是否被声明为final，只有类可以设置 ACC_SUPER 0x0020 是否允许使用invokespecial字节码指令的新语义． ACC_INTERFACE 0x0200 标志这是一个接口 ACC_ABSTRACT 0x0400 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 ACC_SYNTHETIC 0x1000 标志这个类并非由用户代码产生 ACC_ANNOTATION 0x2000 标志这是一个注解 ACC_ENUM 0x4000 标志这是一个枚举 常量池Constant pool意为常量池。常量池可以理解成Class文件中的资源仓库。主要存放的是两大类常量：字面量(Literal) 和 符号引用(Symbolic References)。字面量类似于java中的常量概念，如文本字符串，final常量等，而符号引用则属于编译原理方面的概念，包括以下三种: 类和接口的全限定名(Fully Qualified Name) 字段的名称和描述符号(Descriptor) 方法的名称和描述符 不同于C/C++, JVM是在加载Class文件的时候才进行的动态链接，也就是说这些字段和方法符号引用只有在运行期转换后才能获得真正的内存入口地址。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或运行时解析并翻译到具体的内存地址中。 直接通过反编译文件来查看字节码内容：123456#1 = Methodref #4.#18 // java/lang/Object.\"&lt;init&gt;\":()V#4 = Class #21 // java/lang/Object#7 = Utf8 &lt;init&gt;#8 = Utf8 ()V#18 = NameAndType #7:#8 // \"&lt;init&gt;\":()V#21 = Utf8 java/lang/Object 第一个常量是一个方法定义，指向了第4和第18个常量。以此类推查看第4和第18个常量。最后可以拼接成第一个常量右侧的注释内容:1java/lang/Object.\"&lt;init&gt;\":()V 这段可以理解为该类的实例构造器的声明，由于Main类没有重写构造方法，所以调用的是父类的构造方法。此处也说明了Main类的直接父类是Object。该方法默认返回值是V, 也就是void，无返回值。 同理可分析第二个常量:123456#2 = Fieldref #3.#19 // com/rhythm7/Main.m:I#3 = Class #20 // com/rhythm7/Main#5 = Utf8 m#6 = Utf8 I#19 = NameAndType #5:#6 // m:I#20 = Utf8 com/rhythm7/Main 此处声明了一个字段m，类型为I, I即是int类型。关于字节码的类型对应如下： 标识字符 含义 B 基本类型byte C 基本类型char D 基本类型double F 基本类型float I 基本类型int J 基本类型long S 基本类型short Z 基本类型boolean V 特殊类型void L 对象类型，以分号结尾，如Ljava/lang/Object; 对于数组类型，每一位使用一个前置的”[“字符来描述，如定义一个java.lang.String[][]类型的维数组，将被记录为”[[Ljava/lang/String;” 方法表集合在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现，暂且不管字节码文件的16进制文件内容如何，我们直接看反编译后的内容。123private int m; descriptor: I flags: ACC_PRIVATE 此处声明了一个私有变量m，类型为int，返回值为int 12345678910111213public com.rhythm7.Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/rhythm7/Main; 这里是构造方法：Main()，返回值为void, 公开方法。code内的主要属性为: stack最大操作数栈，JVM运行时会根据这个值来分配栈帧(Frame)中的操作栈深度,此处为1 locals:局部变量所需的存储空间，单位为Slot, Slot是虚拟机为局部变量分配内存时所使用的最小单位，为4个字节大小。方法参数(包括实例方法中的隐藏参数this)，显示异常处理器的参数(try catch中的catch块所定义的异常)，方法体中定义的局部变量都需要使用局部变量表来存放。值得一提的是，locals的大小并不一定等于所有局部变量所占的Slot之和，因为局部变量中的Slot是可以重用的。 args_size:方法参数的个数，这里是1，因为每个实例方法都会有一个隐藏参数this attribute_info方法体内容，0,1,4为字节码”行号”，该段代码的意思是将第一个引用类型本地变量推送至栈顶，然后执行该类型的实例方法，也就是常量池存放的第一个变量，也就是注释里的”java/lang/Object.”“:()V”, 然后执行返回语句，结束方法。 LineNumberTable该属性的作用是描述源码行号与字节码行号(字节码偏移量)之间的对应关系。可以使用 -g:none 或-g:lines选项来取消或要求生成这项信息，如果选择不生成LineNumberTable，当程序运行异常时将无法获取到发生异常的源码行号，也无法按照源码的行数来调试程序。 LocalVariableTable该属性的作用是描述帧栈中局部变量与源码中定义的变量之间的关系。可以使用 -g:none 或 -g:vars来取消或生成这项信息，如果没有生成这项信息，那么当别人引用这个方法时，将无法获取到参数名称，取而代之的是arg0, arg1这样的占位符。start 表示该局部变量在哪一行开始可见，length表示可见行数，Slot代表所在帧栈位置，Name是变量名称，然后是类型签名。 同理可以分析Main类中的另一个方法”inc()”:方法体内的内容是：将this入栈，获取字段#2, 将int类型的1入栈，将栈内顶部的两个数值相加，返回一个int类型的值。 SourceFile源码文件名称 实战分析try-catch-finally通过以上一个最简单的例子，可以大致了解源码被编译成字节码后是什么样子的。下面利用所学的知识点来分析一些Java问题:1234567891011121314public class TestCode &#123; public int foo() &#123; int x; try &#123; x = 1; return x; &#125; catch (Exception e) &#123; x = 2; return x; &#125; finally &#123; x = 3; &#125; &#125;&#125; 试问当不发生异常和发生异常的情况下，foo()的返回值分别是多少。使出老手段12javac TestCode.javajavap -verbose TestCode.class 查看字节码的foo方法内容:12345678910111213141516171819202122232425262728293031323334353637public int foo(); descriptor: ()I flags: ACC_PUBLIC Code: stack=1, locals=5, args_size=1 0: iconst_1 //int型1入栈 -&gt;栈顶=1 1: istore_1 //将栈顶的int型数值存入第二个局部变量 -&gt;局部2=1 2: iload_1 //将第二个int型局部变量推送至栈顶 -&gt;栈顶=1 3: istore_2 //!!将栈顶int型数值存入第三个局部变量 -&gt;局部3=1 4: iconst_3 //int型3入栈 -&gt;栈顶=3 5: istore_1 //将栈顶的int型数值存入第二个局部变量 -&gt;局部2=3 6: iload_2 //!!将第三个int型局部变量推送至栈顶 -&gt;栈顶=1 7: ireturn //从当前方法返回栈顶int数值 -&gt;1 8: astore_2 // -&gt;局部3=Exception 9: iconst_2 // -&gt;栈顶=2 10: istore_1 // -&gt;局部2=2 11: iload_1 //-&gt;栈顶=2 12: istore_3 //!! -&gt;局部4=2 13: iconst_3 // -&gt;栈顶=3 14: istore_1 // -&gt;局部1=3 15: iload_3 //!! -&gt;栈顶=2 16: ireturn // -&gt; 2 17: astore 4 //将栈顶引用型数值存入第五个局部变量=any 19: iconst_3 //将int型数值3入栈 -&gt; 栈顶3 20: istore_1 //将栈顶第一个int数值存入第二个局部变量 -&gt; 局部2=3 21: aload 4 //将局部第五个局部变量(引用型)推送至栈顶 23: athrow //将栈顶的异常抛出 Exception table: from to target type 0 4 8 Class java/lang/Exception //0到4行对应的异常，对应#8中储存的异常 0 4 17 any //Exeption之外的其他异常 8 13 17 any 17 19 17 any 在字节码的4,5，以及13,14中执行的是同一个操作，就是将int型的3入操作数栈顶，并存入第二个局部变量。这正是我们源码在finally语句块中内容。也就是说，JVM在处理异常时，会在每个可能的分支都将finally语句重复执行一遍。通过一步步分析字节码，可以得出最后的运行结果是： 不发生异常时: return 1 发生异常时: return 2 发生非Exception及其子类的异常，抛出异常，不返回值 以上例子来自于《深入理解Java虚拟机 JVM高级特性与最佳实践》关于虚拟机字节码指令表，也可以在《深入理解Java虚拟机 JVM高级特性与最佳实践-附录B》中获取。 kotlin 函数扩展的实现kotlin提供了扩展函数的语言特性，借助这个特性，我们可以给任意对象添加自定义方法。以下示例为Object添加”sayHello”方法123456//SayHello.ktpackage com.rhythm7fun Any.sayHello() &#123; println(\"Hello\")&#125; 编译后，使用javap查看生成SayHelloKt.class文件的字节码。123456789101112131415161718192021222324252627282930313233343536Classfile /E:/JavaCode/TestProj/out/production/TestProj/com/rhythm7/SayHelloKt.classLast modified 2018-4-8; size 958 bytes MD5 checksum 780a04b75a91be7605cac4655b499f19 Compiled from \"SayHello.kt\"public final class com.rhythm7.SayHelloKt minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_FINAL, ACC_SUPERConstant pool: //省略常量池部分字节码&#123; public static final void sayHello(java.lang.Object); descriptor: (Ljava/lang/Object;)V flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL Code: stack=2, locals=2, args_size=1 0: aload_0 1: ldc #9 // String $receiver 3: invokestatic #15 // Method kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V 6: ldc #17 // String Hello 8: astore_1 9: getstatic #23 // Field java/lang/System.out:Ljava/io/PrintStream; 12: aload_1 13: invokevirtual #28 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V 16: return LocalVariableTable: Start Length Slot Name Signature 0 17 0 $receiver Ljava/lang/Object; LineNumberTable: line 4: 6 line 5: 16 RuntimeInvisibleParameterAnnotations: 0: 0: #7()&#125;SourceFile: \"SayHello.kt\" 观察头部发现,koltin为文件SayHello生成了一个类，类名”com.rhythm7.SayHelloKt”.由于我们一开始编写SayHello.kt时并不希望SayHello是一个可实例化的对象类，所以，SayHelloKt是无法被实例化的，SayHelloKt并没有任何一个构造器。再观察唯一的一个方法：发现Any.sayHello()的具体实现是静态不可变方法的形式:1public static final void sayHello(java.lang.Object); 所以当我们在其他地方使用Any.sayHello()时，事实上等同于调用java的SayHelloKt.sayHello(Object)方法。顺便一提的是，当扩展的方法为Any时，意味着Any是non-null的，这时，编译器会在方法体的开头检查参数的非空，即调用kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull(Object value, String paramName)方法来检查传入的Any类型对象是否为空。如果我们扩展的函数为Any?.sayHello()，那么在编译后的文件中则不会有这段字节码的出现。","categories":[{"name":"Java","slug":"Java","permalink":"jaminchanks.github.io.git/categories/Java/"}],"tags":[]},{"title":"Flutter初试","slug":"Android/Flutter初试","date":"2018-03-01T16:19:47.470Z","updated":"2018-03-13T15:10:13.569Z","comments":true,"path":"2018/03/02/Android/Flutter初试/","link":"","permalink":"jaminchanks.github.io.git/2018/03/02/Android/Flutter初试/","excerpt":"Flutter是谷歌推出的一款跨平台移动开发解决方法。使用dart语言进行开发。","text":"Flutter是谷歌推出的一款跨平台移动开发解决方法。使用dart语言进行开发。在Flutter官网有关于如何构建一个Flutter应用的教程。 下载与配置1. 首先在官网下载所需要的开发工具：https://flutter.io/setup-windows/ 2. 利用git工具下载Flutter SDK1git clone -b beta https://github.com/flutter/flutter.git 将Flutter SDK的路径flutter\\bin添加到环境变量path中 3. win + R，输入cmd，调出终端窗口，执行以下命令，检查配置环境：1flutter doctor 输出结果大致如下：123456789[√] Flutter (Channel beta, v0.1.5, on Microsoft Windows [Version 10.0.16299.125], locale zh-CN)[√] Android toolchain - develop for Android devices (Android SDK 27.0.3)[√] Android Studio (version 3.0)[!] IntelliJ IDEA Ultimate Edition (version 2017.3) X Flutter plugin not installed; this adds Flutter specific functionality. X Dart plugin not installed; this adds Dart specific functionality.[√] Connected devices (1 available)! Doctor found issues in 1 category. 根据输出判断环境是否配置成功。 * 由于我大清自有国情所在，所以下载与配置略有不同123456export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cngit clone -b dev https://github.com/flutter/flutter.gitexport PATH=\"$PWD/flutter/bin:$PATH\"cd ./flutterflutter doctor 在windows上需要设置环境变量PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL，才能进行后续操作 4. 配置编辑器这里推荐使用Android Studio.在Android Studio中下载插件:点击 File&gt;Settings&gt;Plugins，Browse repositories… 搜索Flutter插件并进行安装，当提示需要安装Dart插件时点击确认。然后重启Android Studio。 新建工程安装插件之后，选择 File&gt;New Flutter Project&gt;Flutter application 即可创建一个Flutter工程。对于我们新建的项目工程，生成的flutter代码位置在lib/main.dart中项目在Android Studio中的配置和运行和Android的基本类似。 热加载（hot reload）按ctrl+s保存代码或者点击工具栏的闪电符号按钮，即可在模拟器中看到效果, 第一个app新建项目会主动生成文件main.dart. 12345678910111213141516171819import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( child: new Text('Hello World'), ), ), ); &#125; main函数后的 =&gt; 符号表示单语句函数 app 继承了类StatelessWidget，使得app本身就是一个widget,在flutter中，大多数事物都是widget,包括对齐(alignment), 间距(padding)和布局(layout) 主题组件采用了MaterialApp, 来自&#39;package:flutter/material.dart&#39;,提供了appBar,title和body属性 widget的主要作用就是执行build()方法，在该方法中展示组件，以及更下一级组件 该例子中的组件树包含一个Text的子组件，并将其显示在屏幕中间。 主要概念 Stateless widgetsStateless widgets 是状态不可变的，属性固定 Stateful widgetsStateful widgets 属性在生命周期中是可变的实例在pubspec.yaml中添加依赖库english_words123456dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.0 english_words: ^3.1.0 点击Packages get在lib/main.dart中使用依赖库12import 'package:flutter/material.dart';import 'package:english_words/english_words.dart'; 修改main.dart中的代码如下：123456789101112131415161718192021222324252627282930313233343536373839import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center(// child: new Text('Hello World'), child: new RandomWords(), //首字母大写驼峰命名 ), ), ); &#125;&#125;class RandomWords extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return new RandomWordsState(); &#125;&#125;class RandomWordsState extends State&lt;StatefulWidget&gt; &#123; @override Widget build(BuildContext context) &#123; final wordPairs = new WordPair.random(); return new Text(wordPairs.asPascalCase); &#125;&#125; 点击运行项目 Text显示的随机的英文单词 创建列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Welcome to Flutter', home: new RandomWords(), ); &#125;&#125;......class RandomWordsState extends State&lt;StatefulWidget&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize: 18.0); @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('Starup Name Generator'), ), body: _buildSuggestions(), ); &#125; Widget _buildSuggestions() &#123; return new ListView.builder( padding: const EdgeInsets.all(16.0), itemBuilder: (context, i) &#123; if(i.isOdd) return new Divider(); /// i ~/ 2 :将i/2并将整型结果返回 final index = i ~/ 2; if(index &gt;= _suggestions.length) &#123; _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125;, ); &#125; Widget _buildRow(WordPair pair) &#123; return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); &#125;&#125; Scaffold是Material库提供的UI框架(脚手架)，提供包括appbar, title, 和body等属性通过定义ListView.builder创建一个listView，listView的itemBuilder是必须的，负责每个列表项的内容ListTile是一个固定高度的列表子项控件，包含文字和尾部图标，后续会用到 添加交互修改代码如下：123456789101112131415161718192021222324252627282930313233class RandomWordsState extends State&lt;StatefulWidget&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _saved = new Set&lt;WordPair&gt;(); ///定义字体样式 final _biggerFont = const TextStyle(fontSize: 18.0); ...... Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ///尾部 trailing: new Icon( alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), ///点击事件处理 onTap: () &#123; setState(() &#123; if (alreadySaved) &#123; _saved.remove(pair); &#125; else &#123; _saved.add(pair); &#125; &#125;); &#125;, ); &#125; 通过点击事件处理函数onTap将点击项进行收藏和取消，从而改变红心的颜色。setState通知UI进行刷新 界面跳转123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class RandomWordsState extends State&lt;StatefulWidget&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _saved = new Set&lt;WordPair&gt;(); ///定义字体样式 final _biggerFont = const TextStyle(fontSize: 18.0); @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('Starup Name Generator'), actions: &lt;Widget&gt;[ new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved) ], ), body: _buildSuggestions(), ); &#125; void _pushSaved() &#123; Navigator.of(context).push( new MaterialPageRoute( builder: (context) &#123; final tiles = _saved.map( (pair) &#123; return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); &#125;, ); final divided = ListTile.divideTiles( context: context, tiles: tiles, ).toList(); return new Scaffold( appBar: new AppBar( title: new Text('Saved Suggestions'), ), body: new ListView(children: divided), ); &#125;, ), ); &#125; actions用于添加toolbar的菜单，方法_pushSaved()里调用了方法Navigator.of(context).push(Route)用于页面跳转。","categories":[{"name":"Android","slug":"Android","permalink":"jaminchanks.github.io.git/categories/Android/"}],"tags":[]},{"title":"使用Android注解处理器，解放劳动生产力","slug":"Android/AnnotationProcessor注解处理器","date":"2018-02-08T17:56:15.901Z","updated":"2018-02-24T13:50:18.863Z","comments":true,"path":"2018/02/09/Android/AnnotationProcessor注解处理器/","link":"","permalink":"jaminchanks.github.io.git/2018/02/09/Android/AnnotationProcessor注解处理器/","excerpt":"“我已放弃成为珠三角头发最浓密的程序员梦想。”","text":"“我已放弃成为珠三角头发最浓密的程序员梦想。” 简介在android开发中，比较常用到的第三方库中，有不少用到了 注解处理器(Annotation Processor)。比较常见的就有 Butterknife，Dagger2，DBFlow 等。 注解Java中存在不少关于注解的Api, 比如@Override用于覆盖父类方法，@Deprecated表示已舍弃的类或方法属性等，android中又多了一些注解的扩展，如@NonNull, @StringRes, @IntRes等。 代码自动生成使用代码自动生成，一是为了提高编码的效率，二是避免在运行期大量使用反射，通过在编译期利用反射生成辅助类和方法以供运行时使用。 注解处理器的处理步骤主要有以下： 在java编译器中构建 编译器开始执行未执行过的注解处理器 循环处理注解元素(Element)，找到被该注解所修饰的类，方法，或者属性 生成对应的类，并写入文件 判断是否所有的注解处理器都已执行完毕，如果没有，继续下一个注解处理器的执行(回到步骤1) Butterknife注解处理器的例子Butterknife的工作方式如下： 定义一个非私有的属性变量 添加该属性变量的注解和id 调用Butterknife.bind(..)方法。 当你点击Android Studio的Build按钮时，Butterknife先是按照上述步骤生成了对应的辅助类和方法。在代码执行到bind()方法时，Butterknife就去调用之前生成的辅助类方法，，完成对被注解元素的赋值操作。 自定义注解处理器了解了基本的知识点后，我们应该尝试去使用这些技巧。接下来是实践时间，我们来开发一个简单的例子，利用注解处理器来自动产生随机数字和随机字符串。 首先创建一个project。 创建lib_annotations，这是一个纯java的module，不包含任何android代码，只用于存放注解。 创建lib_compiler，这同样是一个纯java的module。该module依赖于步骤2创建的module_annotation,处理注解的代码都在这里，该moduule最终不会被打包进apk，所以你可以在这里导入任何你想要的任意大小依赖库。 创建lib_api，对该module不做要求，可以是android library或者java library或者其他的。该module用于调用步骤3生成的辅助类方法。 1. 添加注解在lib_annotations中添加两个注解：RandomString, RandomInt，分别用于生成随机数字和随机字符串:1234@Retention(CLASS)@Target(value = FIELD)public @interface RandomString &#123;&#125; 123456@Retention(CLASS)@Target(value = FIELD)public @interface RandomInt &#123; int minValue() default 0; int maxValue() default 65535;&#125; @interface自定义注解，使用 @interface 作为类名修饰符 @Target该注解所能修饰的元素类型，可选类型如下： 123456789101112131415public enum ElementType &#123; TYPE, //类 FIELD, //属性 METHOD, //方法 PARAMETER, //参数 CONSTRUCTOR, //构造函数 LOCAL_VARIABLE, ANNOTATION_TYPE, PACKAGE, TYPE_PARAMETER, TYPE_USE; private ElementType() &#123; &#125;&#125; @Retention该注解的保留策略，有三种选项： 1234567public enum RetentionPolicy &#123; SOURCE, //被编译器所忽略 CLASS, //被编译器保留至类文件，但不会保留至运行时 RUNTIME //保留至类文件，且保留至运行时，能在运行时反射该注解修饰的对象&#125; 2. 注解处理器真正处理注解并生成代码的操作都在这里。在写代码之前我们需要先导入两个重要的库，以及我们的注解模块：123compile 'com.google.auto.service:auto-service:1.0-rc4'compile 'com.squareup:javapoet:1.9.0'implementation project(':lib_annotations') 新建类RandomProcessor.java:1234567891011121314151617181920212223@AutoService(Processor.class)public class RandomProcessor extends AbstractProcessor&#123; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return super.getSupportedSourceVersion(); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; return super.getSupportedAnnotationTypes(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; return false; &#125;&#125; @AutoService@AutoService(Processor.class)会告诉编译器该注解处理器的存在，并在编译时自动在META-INF/services下生成javax.annotation.processing.Processor文件，文件的内容为 1com.rhythm7.lib_compiler.RandomProcessor 也就是说，你所声明的注解处理器都会在被写入这个配置文件中。这样子，当外部程序装载这个模块的时候，就能通过该模块的jar包下的META-INF/services下找到具体的注解处理器的实现类名，并加载实例化，完成模块的注入。注解处理器需要实现AbstractProcessor接口，并实现对应的方法 init() 可选在该方法中可以获取到processingEnvironment对象，借由该对象可以获取到生成代码的文件对象, debug输出对象，以及一些相关工具类 getSupportedSourceVersion()返回所支持的java版本，一般返回当前所支持的最新java版本即可 getSupportedAnnotationTypes()你所需要处理的所有注解，该方法的返回值会被process()方法所接收 process() 必须实现扫描所有被注解的元素，并作处理，最后生成文件。该方法的返回值为boolean类型，若返回true,则代表本次处理的注解已经都被处理，不希望下一个注解处理器继续处理，否则下一个注解处理器会继续处理。 初始化较详细代码如下:1234567891011121314151617181920212223242526272829private static final List&lt;Class&lt;? extends Annotation&gt;&gt; RANDOM_TYPES = Arrays.asList(RandomInt.class, RandomString.class);private Messager messager;private Types typesUtil;private Elements elementsUtil;private Filer filer;private TypeonProcess()per.init(processingEnv); messager = processingEnv.getMessager(); typesUtil = processingEnv.getTypeUtils(); elementsUtil = processingEnv.getElementUtils(); filer = processingEnv.getFiler();&#125;@Overridepublic SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported();&#125;@Overridepublic Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; annotations = new LinkedHashSet&lt;&gt;(); for (Class&lt;? extends Annotation&gt; annotation : RANDOM_TYPES) &#123; annotations.add(annotation.getCanonicalName()); &#125; return annotations;&#125; 处理注解在process()方法中执行以下操作： 扫描所有注解元素，并对注解元素的类型做判断 1234567891011121314151617for (Element element : roundEnv.getElementsAnnotatedWith(RandomInt.class)) &#123; //AnnotatedRandomInt是对被RandomInt注解的Elment的简单封装 AnnotatedRandomInt randomElement = new AnnotatedRandomInt(element); messager.printMessage(Diagnostic.Kind.NOTE, randomElement.toString()); //判断被注解的类型是否符合要求 if (!element.asType().getKind().equals(TypeKind.INT)) &#123; messager.printMessage(Diagnostic.Kind.ERROR, randomElement.getSimpleClassName().toString() + \"#\" + randomElement.getElementName().toString() + \" is not in valid type int\"); &#125; //按被注解元素所在类的完整类名为key将被注解元素存储进Map中，后面会根据key生成类文件 String qualifier = randomElement.getQualifiedClassName().toString(); if (annotatedElementMap.get(qualifier) == null) &#123; annotatedElementMap.put(qualifier, new ArrayList&lt;AnnotatedRandomElement&gt;()); &#125; annotatedElementMap.get(qualifier).add(randomElement);&#125; 生成类文件将之前以注解所在类为key的map遍历，并以key值为分组生成类文件。123456for (Map.Entry&lt;String, List&lt;AnnotatedRandomElement&gt;&gt; entry : annotatedElementMap.entrySet()) &#123; MethodSpec constructor = createConstructor(entry.getValue()); TypeSpec binder = createClass(getClassName(entry.getKey()), constructor); JavaFile javaFile = JavaFile.builder(getPackage(entry.getKey()), binder).build(); javaFile.writeTo(filer);&#125; 生成类、构造函数、代码段以及文件都是利用到了javapoet依赖库。当然你也可以选择拼接字符串和自己用文件IO写入，但是用javapoet要更方便得多。123456789101112131415161718192021222324252627282930313233private MethodSpec createConstructor(List&lt;AnnotatedRandomElement&gt; randomElements) &#123; AnnotatedRandomElement firstElement = randomElements.get(0); MethodSpec.Builder builder = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(TypeName.get(firstElement.getElement().getEnclosingElement().asType()), \"target\"); for (int i = 0; i &lt; randomElements.size(); i++) &#123; addStatement(builder, randomElements.get(i)); &#125; return builder.build();&#125;private void addStatement(MethodSpec.Builder builder, AnnotatedRandomElement randomElement) &#123; builder.addStatement(String.format( \"target.%1$s = %2$s\", randomElement.getElementName().toString(), randomElement.getRandomValue()) );&#125;private TypeSpec createClass(String className, MethodSpec constructor) &#123; return TypeSpec.classBuilder(className + \"_Random\") .addModifiers(Modifier.PUBLIC, Modifier.FINAL) .addMethod(constructor) .build();&#125;private String getPackage(String qualifier) &#123; return qualifier.substring(0, qualifier.lastIndexOf(\".\"));&#125;private String getClassName(String qualifier) &#123; return qualifier.substring(qualifier.lastIndexOf(\".\") + 1);&#125; 通过以上几行代码，创建了类文件。在类的构造函数中添加参数(target), 并为每一个被注解元素添加语句”target.%1$s = %2$s”，最后通过javaFile.writeTo(filer)完成文件写入。 3. 调用生成类的方法在lib_api中新建一个类：RandomUtil.java，添加注入方法：12345public static void inject(Object object) &#123; Class bindingClass = Class.forName(object.getClass().getCanonicalName() + \"_Random\"); Constructor constructor = bindingClass.getConstructor(object.getClass()); constructor.newInstance(object);&#125; 这里利用反射找到了以“Object类名_Random”命名的生成类，并调用它的构造方法。而在我们之前的注解处理器中，我们已在生成类的构造方法中实现了属性的赋值操作。 4. 使用生成类在app module中依赖刚才创建的库：123implementation project(':lib_annotations')implementation project(':lib_api')annotationProcessor project(':lib_compiler') 在Activity中的使用123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; @RandomInt(minValue = 10, maxValue = 1000) int mRandomInt; @RandomString String mRandomString; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); RandomUtil.inject(this); Log.i(\"RandomInt ==&gt; \", mRandomInt + \"\"); Log.i(\"RandomString ==&gt; \", mRandomString); &#125;&#125; 编译，运行，查看结果：1202-11 18:38:51.747 7887-7887/com.rhythm7.annotationprocessordemo I/RandomInt ==&gt;: 70002-11 18:38:51.747 7887-7887/com.rhythm7.annotationprocessordemo I/RandomString ==&gt;: HhRayFyTtt 被注解的元素成功被自动赋值，说明注入成功。 完整的demo地址：github 原文地址：http://www.unfishable.com 调试注解处理器的debug跟普通的代码debug有点不同： 在当前工程路径下输入命令1gradlew --no-daemon -Dorg.gradle.debug=true :app:clean :app:compileDebugJavaWithJavac 并在Edit Configurations中新添加一个远程配置(remote)，名字随意，端口为5005。然后点击debug按钮，就可以连接上远程调试器进行Annotation的调试了。","categories":[{"name":"Android","slug":"Android","permalink":"jaminchanks.github.io.git/categories/Android/"}],"tags":[]},{"title":"测试专用","slug":"Others/测试专用","date":"2018-02-04T13:09:42.472Z","updated":"2020-07-18T17:45:58.198Z","comments":true,"path":"2018/02/04/Others/测试专用/","link":"","permalink":"jaminchanks.github.io.git/2018/02/04/Others/测试专用/","excerpt":"","text":"测试专用123","categories":[{"name":"Others","slug":"Others","permalink":"jaminchanks.github.io.git/categories/Others/"}],"tags":[]},{"title":"个人博客搭建记录","slug":"Others/博客搭建记录","date":"2018-02-04T13:09:42.472Z","updated":"2018-02-11T19:23:34.066Z","comments":true,"path":"2018/02/04/Others/博客搭建记录/","link":"","permalink":"jaminchanks.github.io.git/2018/02/04/Others/博客搭建记录/","excerpt":"生命在于折腾","text":"生命在于折腾 最近好冷~~~哆嗦着手我写下了这篇文章。关于如何搭建的目前这个博客，先简单介绍一下： 这个博客是用Hexo搭建的 评论系统使用来必力 主题使用的是icarus 另外本着折腾到底的目的，图床用到的是一个国外的网站 平时用markdown编写文章，编辑器使用的是Atom, 一个21世纪程序员专用的hackable的编辑器 搭建Hexohexo是啥？官网在此 一个快速、简洁且高效的博客框架 官网有中文版的文档…… 这让一切都变得更简单了。 按官网说的，先把两个重要的工具有给安装了。 nodejs git 接下来就到你想放置博客文件的路径下执行以下命令12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 先说下在这里可能遇到的问题，那就是npm死活连不上。嗯，也许给他设置个国内的镜像源，比如淘宝的。1npm set registry https://registry.npm.taobao.org 安装完毕，会出现以下提示： 打开浏览器就可以看见一个搭建成功的hexo博客了。 这里顺便说一个可能出现的问题，就是打开浏览器后页面一直在加载就是出不来，可能是端口冲突了。改一下运行的端口，-p用于指定运行的端口，比如75831hexo server -p 7583 编写文章在运行的结果中看到里面内置了一篇Hello Word的文章。文章在本地的对应地址是..\\blog\\source\\_posts。在该地址新建一个测试的文件夹test1.md，写入以下内容：1# Test!!! 刷新一下浏览器，对应的文章就能显示在浏览器上了。 部署项目单单只是在本地跑起来是不够了。下一步骤是将他部署到github上。在github上新建一个仓库，这里要注意，仓库的命名方式为&lt;你的账号&gt;.github.io,比如我的账号为jaminchanks，对应的仓库名就为jaminchanks.github.io。 部署方法1方法一是交给hexo去部署，新建完远程仓库后，打开blog文件夹下的_config.yml,修改以下代码1234deploy: type: git repo: https://github.com/jaminchanks/jaminchanks.github.io.git branch: master 指定远程仓库的相关信息。之后运行代码123npm install hexo-deployer-git --savehexo ghexo d 就可以将本地的文件都部署到github上了。同时，在浏览器上访问http://jaminchanks.github.io就可以访问到自己的博客了。 部署方法2另一种部署的方法是，将每次hexo g生成的文件复制到指定文件并手动提交到github上。新建远程仓库完成后,到blog目录下，运行以下命令将本地仓库与远程仓库关联。12345mkdir -p .deploye/jaminchanks.github.iocd .deploye/jaminchanks.github.iogit init git remote add origin https://github.com/jaminchanks/jaminchanks.github.io 回到blog目录下，执行以下代码就可以将博客部署到github上了。 123456hexo gcp -R public/* .deploy/jaminchanks.github.io/cd .deploy/jaminchanks.github.iogit add .git commit -m “update”git push origin master 将以上代码保存到文件deploy.sh中，以后就可以一键部署了。 主题Hexo的主题可以在官网找到。可选样式还算挺多的，下载下来后还可以自己定义。 评论系统一开始使用的评论系统是gitment，但是后来，我看到了有一个来自棒子国的第三方评论系统来必力，觉得也挺不错的，所以就换成来必力了。 图片服务器图片服务器之前尝试过https://cloudinary.com/， 有免费套餐，跟七牛差不多，但是还不够稳定，最后还是使用了七牛。 Atom最容易遇到的问题Atom使用答疑怎么取消末尾空白行自动剔除？– 禁用自带 whitespace 插件即可。怎么将TAB从空格改为真TAB？– 设置-&gt;Tab Mode 从 Soft 改为 Hard，同时将长度设置为4我喜欢查看 空格和 TAB，还有换行符，让他们显示出来？– Settings-&gt;Editor-&gt;Show Invisibles如何取消括号补全？– 设置-&gt;Packages-&gt;禁用 Bracket 插件即可。我从 sublime 过来，如何增加文档缩略图 minimap？– 设置-&gt;Install-&gt;安装 MiniMap 即可如何启用Vim模式？– 设置-&gt;Install-&gt;VimMode如何禁止按回车实现自动补全（有时想换行但是变成使用补全了）？– 设置-&gt;Packages-&gt;Autocomplete Plus-&gt;将Tab+Enter改为Tab(Atom内容来自知乎)","categories":[{"name":"Others","slug":"Others","permalink":"jaminchanks.github.io.git/categories/Others/"}],"tags":[]},{"title":"OpenGL ES2 For Android 4.添加纹理","slug":"OpenGL/OpenGL_ES2_For_Android笔记4","date":"2018-01-18T13:53:29.453Z","updated":"2018-02-10T10:54:00.684Z","comments":true,"path":"2018/01/18/OpenGL/OpenGL_ES2_For_Android笔记4/","link":"","permalink":"jaminchanks.github.io.git/2018/01/18/OpenGL/OpenGL_ES2_For_Android笔记4/","excerpt":"岁月的纹理","text":"岁月的纹理 纹理 在OpenGL中，纹理（材质）可以理解成图像，图片或者由数学算法生成的矢量图。每个纹理都是由许多个纹理元素组成的，也就是说纹理元素是纹理的基本组成单位，就好像片元是几何图元（由顶点光栅化后形成的几何图形）的基本组成单位，像素是屏幕尺寸的基本组成单位一样。 一般建议将需要加载的图片资源放在/res/drawable-nodpi/目录下。纹理也有属于自己的空间坐标系，以左下为原点，两个方向上的轴分别为S，T。 在OpenGL ES 2.0中，要求纹理每个维度的大小为2的n次方大小，如：128， 256， 512。这样是为了纹理的处理方便。纹理一般也有大小限制，如最大为2048 * 2048; 纹理过滤 当纹理被加载并最终被映射到渲染表面的图元上时，由于每个纹理元素和片元的映射关系并不一定是一一对应的，可能一个片元对应于多个纹理元素，也可能多个片元去对应于一个纹理元素，也就是说纹理最终要被放大或缩小，因此我们还要处理这种映射关系。 处理这种映射关系的方法就是用到OpenGL中的纹理过滤器（Texture Filtering ）。首先介绍两种最基本的过滤模式：最近邻过滤，双线性过滤。 最近邻过滤（Nearest-Neighbor Filtering） 最近邻过滤也就是最近点采样法，对于每个片元，会对最接近它的纹理单元进行采样，并使用该采样结果。对于以下图片： 当我们放大纹理时，因为多个片元才对应于一个纹理，所以会看到比较明显的锯齿效果，如下图所示： 而当我们缩小纹理时，由于一个片元要被塞进更多的纹理元素，最终会出现纹理细节丢失的情况： 双线性过滤（Bilinear Filtering） 双线性过滤采用双线性算法对纹理单元进行采样，即对每个片元最临近的四个纹理元素进行线性插值算法计算，将计算结果应用于该片元中。这种做法会让显示效果变得更光滑，但当放大比例比较大时，还是可以看出一些锯齿。 虽然双线性过滤对于纹理的放大处理效果还算可以，但是对于纹理缩小的处理表现确不尽人意。最后还是会出现多个纹理被塞进一个片元的情况，所以还是会出现细节丢失。以下为纹理被缩小1/8的效果。 MIP贴图（Mipmapping） 由于以上两种方式对于缩小纹理的表现实在不佳，我们引入了mipmap。mip取自拉丁语multum in parvo的首字母，意思是“放置很多东西的小空间”。使用mipmap技术可以生成一组不同缩放等级的纹理，每一个级别的纹理都是原先尺寸的纹理按1/4比例缩小的复制品，即每一维度缩小一半。比如我们的原先纹理尺寸为256×256，则mipmap可以生成8个级别的纹理，分别128×128，64×64×32×32，16×16，8×8；4×4，2×2，1×1。生成mipmap组图会占用更多的内存，但是却减少了渲染时的负担，因为缓存区使用的对应等级的纹理，而不是原始纹理。最终纹理被映射到图元时，OpenGL会使用最合适等级的纹理，再对其使用双线性插值处理。相较于双线性过滤，对刚才的纹理缩小1/8，mipmap保留的细节更多。 三线性过滤 当使用mimap贴图后我们使用的是双线性插值处理，那么有可能在渲染场景中进行mipmap的不同等级切换时，会出现明显的跳跃或线条干扰，这时使用三线性过滤可以有助于消除这种影响，三线性过滤采用的是使用8×8进行插值计算映射结果。OpenGL中可用的过滤方式如下： 参数 说明 GL_NEAREST 最近邻过滤 GL_NEAREST_MIPMAP_NEAREST 使用MIP贴图的最近邻过滤 GL_NEAREST_MIPMAP_LINEAR 使用MIP贴图级别之间插值的最近邻过滤 GL_LINEAR 双线性插值 GL_LINEAR_MIPMAP_NEAREST 使用MIP贴图的双线性插值 GL_LINEAR_MIPMAP_LINEAR 使用MIP贴图的三线性插值 加载纹理定义顶点和shaders顶点坐标要与纹理坐标一一对应，定义数据如下：123456789private val verticesData = floatArrayOf( //X, Y, S, T 0f, 0f, 0.5f, 0.5f, -0.5f, -0.5f, 0f, 1f, 0.5f, -0.5f, 1f, 1f, 0.5f, 0.5f, 1f, 0f, -0.5f, 0.5f, 0f, 0f, -0.5f, -0.5f, 0f, 1f ) shader代码：123456789101112131415161718192021private val vertexShaderCode = \"\"\" uniform mat4 u_Matrix; attribute vec4 a_Position; attribute vec2 a_TextureCoordinates; varying vec2 v_TextureCoordinates; void main() &#123; v_TextureCoordinates = a_TextureCoordinates; gl_Position = u_Matrix * a_Position; &#125; \"\"\"private val fragmentShaderCode = \"\"\" precision mediump float; uniform sampler2D u_TextureUnit; varying vec2 v_TextureCoordinates; void main() &#123; gl_FragColor = texture2D(u_TextureUnit, v_TextureCoordinates); &#125; \"\"\" u_TextureUnit用于指定使用的纹理单元。在需要的情况下，一个片元着色器可以设置多个纹理，一个纹理的位置值就被称为一个纹理单元(Texture Unit)。该值与激活的纹理单元值相同。 加载纹理在OpenGL中加载纹理的步骤如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344fun loadTexture(context: Context, resourceId: Int): Int &#123; //1. 获取纹理句柄 val textureObjectIds = IntArray(1) glGenTextures(1, textureObjectIds, 0) if (textureObjectIds[0] == 0) &#123; Log.e(\"loadTexture\", \"Could not generate a new OpenGL texture object.\") return 0 &#125; //2. 读取图片资源 val options = BitmapFactory.Options() options.inScaled = false val bitmap = BitmapFactory.decodeResource(context.resources, resourceId, options) if (bitmap == null) &#123; Log.e(\"loadTexture\", \"Resource ID $resourceId could not be decoded\") glDeleteTextures(1, textureObjectIds, 0) return 0 &#125; //3. 绑定纹理句柄 glBindTexture(GL_TEXTURE_2D, textureObjectIds[0]) //4.设置过滤器，如果不设置，纹理将无法正常显示 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR) glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR) //5. 加载图片到纹理 GLUtils.texImage2D(GL_TEXTURE_2D, 0, bitmap, 0) // 6.生成mipmap纹理 // 注意，以下代码可能报错: E/IMGSRV(20095): :0: HardwareMipGen: // Failed to generate texture mipmap levels (error=3) // No OpenGL error will be encountered (glGetError() will return // 0). // 如果发生以上错误，请将图片压缩成正方形，最后的显示效果不会有影响，因为纹理坐标最终会映射到图元对应的坐标中 glGenerateMipmap(GL_TEXTURE_2D) //7. 释放图片资源 bitmap.recycle() //8. 解绑纹理 glBindTexture(GL_TEXTURE_2D, 0) return textureObjectIds[0]&#125; 使用纹理使用纹理的步骤如下：123456789val uTextureUnitLocation = glGetUniformLocation(program, \"u_TextureUnit\")val textureId = loadTexture(context, R.drawable.avatar)//先激活纹理单元0glActiveTexture(GL_TEXTURE0)//绑定纹理到纹理单元0glBindTexture(GL_TEXTURE_2D, textureId) //texture//读取纹理单元0以获取纹理数据glUniform1i(aTextureUnitLocation, 0) 最终运行效果： 最后奉上项目下载地址: github代码","categories":[{"name":"Android OpenGL","slug":"Android-OpenGL","permalink":"jaminchanks.github.io.git/categories/Android-OpenGL/"}],"tags":[]},{"title":"OpenGL ES2 For Android 3.颜色混合和图像变换","slug":"OpenGL/OpenGL_ES2_For_Android笔记3","date":"2018-01-17T18:02:16.239Z","updated":"2018-02-08T18:04:34.651Z","comments":true,"path":"2018/01/18/OpenGL/OpenGL_ES2_For_Android笔记3/","link":"","permalink":"jaminchanks.github.io.git/2018/01/18/OpenGL/OpenGL_ES2_For_Android笔记3/","excerpt":"阳光总在风雨后","text":"阳光总在风雨后 多彩的三角形 我们在上一章节介绍了vertex shader和fragment shader。接下来讲讲fragment shader中的着色机制。定义一个三角形, 其顶点数据及shader代码如下：1234567891011121314151617181920212223242526272829private val verticesData = floatArrayOf( -1f, -1f, 1f, -1f, 0f, 1f)private val colorData = floatArrayOf( 1f, 1f, 0f, 1f, 0f, 1f, 1f, 1f, 1f, 0f, 1f, 1f)private val vertexShaderCode = \"\"\" attribute vec4 a_Position; attribute vec4 a_Color; varying vec4 v_Color; void main() &#123; gl_Position = a_Position; v_Color = a_Color; &#125; \"\"\"private val fragmentShaderCode = \"\"\" precision mediump float; varying vec4 v_Color; void main() &#123; gl_FragColor = v_Color; &#125; \"\"\" vaying变量用于vertex shader和fragment shader之间传递数据。读取顶点颜色数据的方式与读取顶点的方式一致: 123456......colorDataBuff = ByteBuffer .allocateDirect(colorData.size * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer()colorDataBuff?.put(colorData) 1234......colorDataBuff?.position(0)GLES20.glVertexAttribPointer(aColorLocation, 4, GLES20.GL_FLOAT, false, 0, colorDataBuff)GLES20.glEnableVertexAttribArray(aColorLocation) 12345override fun onDrawFrame(gl: GL10?) &#123; GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT) GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 3)&#125; 最终运行结果: 同理可以画出一个矩形。 这里画出的矩形中间有个顶点。使用的颜色是白色。这里有个小技巧，定义顶点是这么定义的：123456789private val verticesData = floatArrayOf( 0f, 0f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, -0.5f )...... 绘制的时候代码是这样子的：1GLES20.glDrawArrays(GLES20.GL_TRIANGLE_FAN, 0, 6) 注意这里使用的GLES20.GL_TRIANGLE_FAN, 表示在绘制的时候会以第一个点为中心，以此来绘制三角形。这样的好处是避免了定义太多重复的顶点。 正射投影(Orthographic projectio) 在开发Android App时，有个问题绕不开的，就是关于屏幕的旋转问题的处理，当然，你可以简单粗暴的把手机屏幕的朝向固定为竖屏或横屏模式，但如果我们要兼容手机的横屏和竖屏情况下的UI绘制，就要下一点功夫了。当我们将刚才绘制矩形的App旋转到横屏时，矩形的形状发生了改变。 对于我们一个在归一化设备坐标系中定义的正方形：在竖屏和横屏状态下被映射到设备屏幕时，正方形的形状就会被拉伸： 为了解决这个问题，使正方形在被绘制到屏幕时还是正方形，我们调整设备的坐标空间。其中一种方式就是将设备较小的一边width保留归一化范围为[-1, 1], 另外较长的一个方向取值则映射为[ -(height/width)， height/width]。 以上这种将物体的原始形状映射到屏幕设备的方式叫做正射投影。 正射投影也称为平行投影，这种投影是一个矩形长方体的平行管道. 它最大的特点是, 无论物体距离相机多远投影后的物体大小尺寸不变. android OpenGL中与正射投影相关的函数有：1orthoM(float[] m, int mOffset, float left,float right, float bottom, float top,float near,float far) orthoM()函数的几个参数分别对应于变换矩阵，读取矩阵数据的偏移起始位置，左右上下近远的空间限制值，最后两个参数形成了我们上面图片的可视空间，超出该空间的物体将不可见。将矩阵乘积于向量以达到对向量进行变化的作用。正射投影变换矩阵的具体计算方式为： 修改我们的vertex shader代码如下：1234567891011private val vertexShaderCode = \"\"\" uniform mat4 u_Matrix; attribute vec4 a_Position; attribute vec4 a_Color; varying vec4 v_Color; void main() &#123; gl_Position = u_Matrix * a_Position; gl_PointSize = 30.0; v_Color = a_Color; &#125; \"\"\" uniform变量用于外部程序向shader传递数据，且数据在shader中无法被改变。继续修改代码：12345678910111213141516171819202122232425262728override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) &#123; ...... val aspectRatio = if (width &gt; height) &#123; width.toFloat() / height.toFloat() &#125; else &#123; height.toFloat() / width.toFloat() &#125; if (width &gt; height) &#123; Matrix.orthoM(projectionMatrix, 0, -aspectRatio, aspectRatio, -1f,1f, 1f, 10f) &#125; else &#123; Matrix.orthoM(projectionMatrix, 0, -1f, 1f, -aspectRatio, aspectRatio, 1f, 10f) &#125;&#125; override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) &#123; ...... uMatrixLocation = GLES20.glGetUniformLocation(program, \"u_Matrix\") ......&#125;override fun onDrawFrame(gl: GL10?) &#123; ...... GLES20.glUniformMatrix4fv(uMatrixLocation, 1, false, projectionMatrix, 0) ......&#125; 最后运行结果： 透视投影（PerspectiveProjection） 除了正射投影之外，还有一种投影称之为透视投影。透视投影和正射投影的区别在于，当摄像机的位置离物体越近，物体的投影区域越大，离得越远，投影越小。在onSurfaceChanged() 方法最后添加两句代码，对物体进行透视投影变换，并在z轴上平移一定的位置使其处于可视空间内：123Matrix.perspectiveM(projectionMatrix, 0, 60f, 1 /aspectRatio, 1f, 10f)Matrix.translateM(projectionMatrix, 0, 0f, 0f, -7f) 按照约定，以及一些历史原因，OpenGL使用的是右手坐标系，也就是说根据你的手指朝向，大拇指为x轴方向，往右为正，其余手指竖直指向为y轴正方向，弯曲则指向z轴的正方向，也就是面对着你的方向。所以越往后，z的值越小。 接着随意更改代码中z轴上的偏移量在(-far, -near)范围内，也就是(-10f, -1f)内,观察屏幕上的图像显示大小。可以发现z的值越小，投影的大小也越小。 画了三个章节的图，下一章节我们从外部来导入图片到OpenGL中。 Tips: 通过引入顶点的第四个坐标点w, 组成齐次坐标系（x, y, z, w），可以实现绘制三维物体的效果。常见的变化矩阵的方法有位移，旋转和放大缩小等操作。具体的计算方式为：沿x轴，y轴，z轴旋转的矩阵计算方式：","categories":[{"name":"Android OpenGL","slug":"Android-OpenGL","permalink":"jaminchanks.github.io.git/categories/Android-OpenGL/"}],"tags":[]},{"title":"OpenGL ES2 For Android 2.OpenGL绘制流程","slug":"OpenGL/OpenGL_ES2_For_Android笔记2","date":"2018-01-17T18:02:16.238Z","updated":"2018-02-08T18:04:34.666Z","comments":true,"path":"2018/01/18/OpenGL/OpenGL_ES2_For_Android笔记2/","link":"","permalink":"jaminchanks.github.io.git/2018/01/18/OpenGL/OpenGL_ES2_For_Android笔记2/","excerpt":"在梦的边缘窥探世界的棱角。","text":"在梦的边缘窥探世界的棱角。 这一章节，我们来画一个矩形。 定义顶点数据 在OpenGL中，只能画点，线和三角形。复杂的图形需要通过这三种最基本的图形来组成和拼接。比如要绘制一个矩形，那么就需要确定该矩形的四个点，并将这四个点用线段连起来组成两个三角形，再由这两个三角形来组成一个矩形。 每个三角形包含三个顶点，每个顶点有两个坐标值(x, y)，于是我们很容易就定义以下顶点数据。1234567891011val verticesOfTriangle = floatArrayOf( // Triangle1 1.0f, 0f, 9f, 14f, 0f, 14f, // Triangle2 2.0f, 0f, 9f, 0f, 9f, 14f) 将数据传递给OpenGL 顶点数据定义好了后，接下来的问题就是怎样将数据传递给OpenGL了。java代码运行于虚拟机中,虚拟机对于内存有回收机制，然而OpenGL是直接使用硬件内存的。于是我们需要将这些数据从Java的内存堆拷贝到本地内存堆中。 123456 val vertexData = ByteBuffer .allocateDirect(verticesOfTriangle.size * 4) //java中每个float类型有四个字节 .order(ByteOrder.nativeOrder()) .asFloatBuffer()vertexData.put(verticesOfTriangle) 通过ByteBuffer.allocateDirect()方法可以直接分配本地内存，以字节作为单位，order()方法指定数据存储顺序，这里不用多做关心，交给系统自己处理，使用ByteOrder.nativeOrder()，最后将其转化为我们可以使用的对象asFloatBuffer(), 并将顶点数据传递其中vertexData.put(vertexData)。 有了顶点数据之后，我们还要告诉OpenGL要用什么颜色去画每个点。这里就需要了解到另一个概念了：fragment(片元); 在OpenGL中，将几何图形的顶点数据转化为屏幕上的每个像素点的过程就叫光栅化。对于每个映射区域就称为一个fragment，一般情况下设备的一个像素点对应一个fragment，而对于高清设备可能好几个像素点才对应一个fragment。 渲染器(Shader) 在已有顶点数据后，我们还需要告诉OpenGL怎样去绘画，这里需要用到两个Shader(渲染器)：Vertex Shader, Fragment Shader,前者负责确定顶点的位置，后者确定顶点的颜色。每有一个顶点数据，Vertex Shader就执行一遍，确定每个点的位置之后就可以将其组合成点，线和三角形了。每光栅化出一个fragment，Fragment Shader就执行一遍，最终确定每个fragment的颜色。每次完成以上操作之后，OpenGL就会将数据写入frame buffer(帧缓存区)中，并最终在屏幕中显示出来。 Shader的定义使用的是GLSL语言(OpenGL Shading Language),其语法类似于C。以下一个最简单的Vertex Shader 和 Fragment Shader: 123456private val vertexShaderCode = \"\"\" attribute vec4 a_Position; void main() &#123; gl_Position = a_Position; &#125; \"\"\" Vertex Shader的每次调用，全局变量gl_Position的值就被确定一次，其将作为该顶点的最终位置。 1234567private val fragmentShaderCode = \"\"\" precision mediump float; uniform vec4 u_Color; void main() &#123; gl_FragColor = u_Color; &#125; \"\"\" 在fragment shader中需要为数据类型设置精度（owp, mediump, high），而在vertex shader中可以不用设置类型精度，其默认为high级别。Fragment Shader的每次调用，gl_FragColor的值就被确定一次，其将作为该片元的最终颜色。 更多GLSLnei内容见GLSL基本知识 编译渲染器代码接下来需要对使用GLSL定义的vertex shader和fragment shader代码进行编译。 12345678910111213141516171819202122232425262728293031/** * 编译shader, 并shader的对象Id * shaderType取值为: GLES20.GL_VERTEX_SHADER 或 GLES20.GL_FRAGMENT_SHADER */fun compileShader(shaderType: Int, shaderCode: String): Int &#123; //创建一个shader对象 val shaderObjectId = GLES20.glCreateShader(shaderType) if (shaderObjectId == 0) &#123; Log.w(\"compileShader()\", \"Could not create new shader.\") return 0 &#125; //加载shader代码 GLES20.glShaderSource(shaderObjectId, shaderCode) //编译shader代码 GLES20.glCompileShader(shaderObjectId) //获取编译结果，并打印日志 val compileStatus = IntArray(1) GLES20.glGetShaderiv(shaderObjectId, GLES20.GL_COMPILE_STATUS, compileStatus, 0) Log.v(\"compileShader()\", \"Result of compile source $shaderCode \\n:\" + \" $&#123;GLES20.glGetShaderInfoLog(shaderObjectId)&#125;\") //判断编译结果 if (compileStatus[0] == 0) &#123; GLES20.glDeleteShader(shaderObjectId) Log.w(\"compileShader()\", \"Compilation of shader failed.\") return 0 &#125; return shaderObjectId&#125; 在上面的获取编译结果部分代码中，我们新建了一个长度为1的一维数组compileStatus，并将编译的结果赋值于它，在OpenGL中，这是一种常见的模式。 链接子程序 下一步是将两个shader链接成一个单独的子程序(program)；1234567891011121314151617181920212223242526272829303132/** * 链接vertex shader和fragment shader到program中 * 如果成功，返回一个program对象Id，否则返回0 */fun linkProgram(vertexShaderId: Int, fragmentShaderId: Int): Int &#123; //创建一个program对象 val programObjectId = GLES20.glCreateProgram() if (programObjectId == 0) &#123; Log.w(\"linkProgram()\", \"Could not create new program\") return 0 &#125; //将shader 加载到program上，并链接program GLES20.glAttachShader(programObjectId, vertexShaderId) GLES20.glAttachShader(programObjectId, fragmentShaderId) GLES20.glLinkProgram(programObjectId) //获取上述操作的结果 val linkStatus = IntArray(1) GLES20.glGetProgramiv(programObjectId, GLES20.GL_LINK_STATUS, linkStatus, 0) Log.v(\"linkProgram()\", \"Result of linking program\\n:\" + \" $&#123;GLES20.glGetShaderInfoLog(programObjectId)&#125;\") //处理链接结果 if (linkStatus[0] == 0) &#123; GLES20.glDeleteProgram(programObjectId) Log.w(\"linkProgram()\", \"Linking program failed\") return 0 &#125; return programObjectId&#125; 将shader链接成program之后，我们就可以通过program来与OpenGL进行交流了。 执行子程序 使用glUseProgram()可以指定OpenGL的渲染子程序。 绘制画顶点 在OPenGL中，使用glGetUniformLocation()方法可以获取指定uniform声明的变量的位置id；使用glGetAttribLocation获取attribe声明的变量的位置id; OPenGL通过获取变量位置id(或称句柄)的方式来改变变量的值。在之前的shader代码中，我们定义了a_Position 和 u_Color, 12345678val uColorLocation = GLES20.glGetUniformLocation(program, \"u_Color\")val aPositionLocation = GLES20.glGetAttribLocation(program, \"a_Position\")//绑定顶点数据，要求缓冲区的数据从位置0开始读取vertexData?.position(0)GLES20.glVertexAttribPointer(aPositionLocation, 2, GLES20.GL_FLOAT, false, 0, vertexData)GLES20.glEnableVertexAttribArray(aPositionLocation) glVertexAttribPointer四个参数分别为： 变量位置； 每个变量值的单位组成个数，我们定义顶点时每个顶点有x,y两个float类型的值，所以这个参数时2； 变量类型； 是否归一化，这里无需考虑，直接false； 该值代表每读取一个顶点需要跳过的总字节数，这里每个顶点有两个向量，每个向量为float类型，各为4个字节，所以该参数值为2 * 4, 不过如果该顶点数组中的顶点是紧密排列的，该参数也可以写0，这时OpenGL会帮我们计算出该值大小； OpenGL读取的数据缓冲区，OpenGL会从该缓冲区的当前位置开始读，所以我们需要将调用方法position(0) glEnableVertexAttribArray的作用：默认情况下，出于性能考虑，所有顶点着色器的属性（Attribute）变量都是不可用的，当调用该方法后，这些顶点数据才可以被使用于渲染。 画颜色12GLES20.glUniform4f(uColorLocation, 1.0f, 1.0f, 1.0f, 1.0f)GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 6) 首先为uColor赋值，uColor是一个vec4变量，后面四个参数分别代码rgba。接着从读取的顶点数据中取值画三角形，从0位置读取，直到第6个顶点，这里我们画的时一个三角形，同理，当我们改变GLES20.GL_TRIANGLES为GL_POINTS或GLES20.GL_LINES时，可以画点和线。 现在我们的Render类的主要代码是这样子的： 123456789101112131415161718192021222324252627override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) &#123; GLES20.glViewport(0, 0, width, height)&#125;override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) &#123; GLES20.glClearColor(0f, 0f, 0f, 0f) val vertexShader = compileShader(GLES20.GL_VERTEX_SHADER, vertexShaderCode) val fragmentShader = compileShader(GLES20.GL_FRAGMENT_SHADER, fragmentShaderCode) val program = linkProgram(vertexShader, fragmentShader) GLES20.glUseProgram(program) aPositionLocation = GLES20.glGetAttribLocation(program, \"a_Position\") uColorLocation = GLES20.glGetUniformLocation(program, \"u_Color\") vertexData?.position(0) GLES20.glVertexAttribPointer(aPositionLocation, 2, GLES20.GL_FLOAT, false, 0, vertexData) GLES20.glEnableVertexAttribArray(aPositionLocation)&#125;override fun onDrawFrame(gl: GL10?) &#123; GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT) GLES20.glUniform4f(uColorLocation, 1.0f, 1.0f, 1.0f, 1.0f) GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 6)&#125; 最终运行结果如下： 呃……好像有什么地方不对。 OpenGL坐标 还记得我们之前定义的顶点数据么。在OpenGL中，坐标系的定义可跟我们想的不一样。默认情况下，我们需要在一个x轴和y轴取值都为[-1, 1]的空间坐标中定义我们的数据，然后这个空间坐标会被投影到屏幕中，超出定义空间范围的数据顶点将在手机屏幕中不可见。这种将数据方式映射到0～1范围之内处理的方式就叫归一化。而这种每个轴都取值[-1, 1]的空间坐标系就叫做归一设备坐标系。 稍微修改了一下我们的顶点数据如下：12345678910private val verticesOfTriangle = floatArrayOf( // Triangle 1 -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, // Triangle 2 -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f) 一个正常的矩形就出来了。 Tips: 画点时，在vertexShader的main函数中指定点的大小：如：gl_PointSize = 30.0;","categories":[{"name":"Android OpenGL","slug":"Android-OpenGL","permalink":"jaminchanks.github.io.git/categories/Android-OpenGL/"}],"tags":[]},{"title":"OpenGL ES2 For Android 1.超简单入门","slug":"OpenGL/OpenGL_ES2_For_Android笔记1","date":"2018-01-17T18:02:16.237Z","updated":"2018-02-08T18:04:34.671Z","comments":true,"path":"2018/01/18/OpenGL/OpenGL_ES2_For_Android笔记1/","link":"","permalink":"jaminchanks.github.io.git/2018/01/18/OpenGL/OpenGL_ES2_For_Android笔记1/","excerpt":"生命潦草，我在弯腰","text":"生命潦草，我在弯腰注：本系列文章选用的编程语言为Kotlin。参考书籍《OpenGL ES2 for Android》 简介理论上来说，我应该要先介绍什么是OpenGL的，然而，如果完全没听说过OpenGL，点进来看这篇文章的可能性也不高。无论如何，为了凑字数，以下稍作简单介绍。 OpenGL，全称Open Graphics Library，是用于渲染2D，3D矢量图形的跨语言，跨平台的应用程序接口。利用OpenGL可以使许多android设备利用硬件加速器的渲染功能，从而使开发者开发出更高端，更生动的动画效果，以及显示三维动画。 检查设备支持在Android设备上开发OpenGL ES2应用，我们需要首先检查设备是否支持。 123456fun isSupportEs2(context: Context): Boolean &#123; val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager val configurationInfo = activityManager.deviceConfigurationInfo return configurationInfo.reqGlEsVersion &gt;= 0x20000&#125; 以上代码对于某些模拟器可能无效，因为模拟器的GPU可能存在的bug，在模拟器环境下可以使用以下代码 123456789101112fun isSupportEs2(context: Context): Boolean &#123; val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager val configurationInfo = activityManager.deviceConfigurationInfo return configurationInfo.reqGlEsVersion &gt;= 0x20000 || (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1 &amp;&amp; (Build.FINGERPRINT.startsWith(\"generic\") || Build.FINGERPRINT.startsWith(\"unknown\") || Build.MODEL.contains(\"google_sdk\") || Build.MODEL.contains(\"Emulator\") || Build.MODEL.contains(\"Android SDK built for x86\")))&#125; 在Android上使用OpenGL需要用到两个最重要的类：GLSurfaceView和GLSurfaceView.Render， GLSurfaceView以下示例一个最简单的OpenGL的代码。 12345678910111213141516171819class MainActivity : AppCompatActivity() &#123; private var glSurfaceView: GLSurfaceView? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) glSurfaceView = GLSurfaceView(this) if(isSupportEs2(this)) &#123; glSurfaceView?.setEGLContextClientVersion(2) glSurfaceView?.setRenderer(FirstRenderer()) // addContentView(glSurfaceView, ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)) &#125; else &#123; toast(\"This device does not support OpenGL ES 2.0.\") //这里的toast是自定义的扩展函数 +_+ &#125; &#125;&#125; 以上代码声明了一个GLSurfaceView对象，可将GLSurfaceView理解为绘制内容的画布控件。我们在Activity的onCreate()方法里将其初始化，若当前设备支持OpenGL ES2则将会GLSurfaceView布局添加到当前布局中，否则提示报错。 在Android中使用GLSurfaceView，我们还要处理GLSurfaceView的生命周期，否则App将有可能在切换至其他App时奔溃。123456789override fun onPause() &#123; super.onPause() glSurfaceView?.onPause() //这里需要注意glSurfaceView可能为空的情况&#125;override fun onResume() &#123; super.onResume() glSurfaceView?.onResume()&#125; GLSurfaceView.RenderGLSurfaceView的内容需要通过Render绘制出来，GLSurfaceView.Render 是一个接口，其子类需要实现以下方法： onSurfaceCreated(GL10glUnused,EGLConfigconfig) 当Surface被创建时，该方法会被调用。情况可能发生于app首次运行，设备被唤醒，或用户返回当前Activity时。该方法可能被多次调用。一般可以在该方法里做初始化操作。 onSurfaceChanged(GL10glUnused,intwidth,intheight) 当当前surface被创建或者尺寸发生改变时，该方法会被调用。如当手机屏幕旋转时该方法就会被调用。 onDrawFrame(GL10glUnused) 每当需要绘制一帧内容时，该方法会被调用。我们需要在该方法里面做些操作，即使只是清屏。如果我们什么都不做的话，屏幕可能会闪烁。绘制画面的代码都放在这个方法里实现。 1234567891011override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) &#123; GLES20.glViewport(0, 0, width, height) //指定surface内容的渲染大小&#125;override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) &#123; GLES20.glClearColor(1.0f, .0f, 0f, 0f) //参数分别rgba中的red, green, blue, transparency&#125;override fun onDrawFrame(gl: GL10?) &#123; GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT) //清除所有颜色并用glClearColor()所指定的颜色填充&#125; 最终运行结果相对比较简单，但我们已经在OpenGL的世界里敲了下门了： Tips:SurfaceView的绘制操作在一个独立的线程中，而不是主线程。如果我们要让SurfaceView去post一个线程，需要调用SurfaceView的queueEvent()方法，如果在SurfaceView的绘制线程中需要更新主线程UI，则需要调用方法Activity的runOnUiThread()方法。surfaceView默认情况下是不断绘制的(RENDERMODE_CONTINUOUSLY)，如果需要改成需要时才绘制，可以通过setRenderMode(int renderMode) 方法并传入RENDERMODE_WHEN_DIRTY参数。","categories":[{"name":"Android OpenGL","slug":"Android-OpenGL","permalink":"jaminchanks.github.io.git/categories/Android-OpenGL/"}],"tags":[]},{"title":"GLSL基础","slug":"OpenGL/GLSL基础","date":"2018-01-17T18:02:16.236Z","updated":"2018-02-08T18:04:35.063Z","comments":true,"path":"2018/01/18/OpenGL/GLSL基础/","link":"","permalink":"jaminchanks.github.io.git/2018/01/18/OpenGL/GLSL基础/","excerpt":"在GLSL中有以下几种常见的变量类型修饰符","text":"在GLSL中有以下几种常见的变量类型修饰符 修饰符 说明 none (默认的可省略)本地变量,可读可写,函数的输入参数既是这种类型 const 声明变量或函数的参数为只读类型 attribute 只能存在于vertex shader中,一般用于保存顶点或法线数据,它可以在数据缓冲区中读取数据 uniform 在运行时shader无法改变uniform变量, 一般用来放置程序传递给shader的变换矩阵，材质，光照参数等等. varying 主要负责在vertex 和 fragment 之间传递变量 attribute： attribute修饰的变量只能使用于vertex shader中，一般用于表示一些顶点的数据，如顶点坐标，纹理坐标，法线，顶点颜色等。在外部应用中，通常使用glVertexAttribPointer（）为每个attribute变量赋值。 uniform： uniform修饰的变量是外部程序传递给shader(vertex和fragment)的变量。外部程序可以通过glUniform**()方法赋值，且通过 glGetUniform**()方法获取该变量的id（或可理解为句柄、指针）。uniform变量类似于C语言里的常量（const），不能被shader程序修改。常用于表示变换矩阵，材质，光照参数和纹理采样器等。 varying： varying修饰的变量用于vertex shader向fragment shader传递数据。外部应用不能使用该变量。一般在vertex shader中修改varying变量值，然后fragment shader中使用该值。该变量在vertex shader及fragment shader中声明必须是一致的。 const : 常量值，在声明时进行初始化，不能在函数中被改写 GLSL的常见基本数据类型如下： 类型 说明 void 无返回值 bool 条件类型，true/false int 16位有符号整数 float 单精度浮点数 vec2 包含了2个浮点数的向量 vec3 包含了3个浮点数的向量 vec4 包含了4个浮点数的向量 ivec2 包含了2个整数的向量 ivec3 包含了3个整数的向量 ivec4 包含了4个整数的向量 bvec2 包含了2个布尔数的向量 bvec3 包含了3个布尔数的向量 bvec4 包含了4个布尔数的向量 mat2 2*2浮点型矩阵 mat3 3*3浮点型矩阵 mat4 4*4浮点型矩阵 sampler1D 由内部纹理函数使用，用于引用一个特定的1D纹理，只能被声明为uniform或函数的参数 sampler2D 用于引用一个2D的纹理常量 sampler3D 用于引用一个3D的纹理常量 基本结构和数组 类型 说明 结构 struct type-name{} 类似c语言中的 结构体 数组 float arr[2] glsl只支持1维数组,数组可以是结构体的成员 向量的分量glsl中的向量(vec2，vec3, vec4)可能代表着不同的意义，比如可以用一个vec4来表示一个空间坐标(x, y, z, w) ，一个颜色(r, g, b, a)，又可以用来表示一个纹理坐标(s, t, p, q)。向量中的任意几个点可以组成一个分向量，如：vector.xz, vector.st， vector.rgb等。 基础类型的运算一般而言，glsl中的基本类型在计算时是强类型的，也就是说不会进行类型的隐式转换：123int a = 1.0; //error 需要强转化：int a = int(1.0)int a = 1.0 + 2; //errorbool a = 0; //error 而以下的情况是允许的： float与vec和mat类型的运算12345vec2 a = vec2(1.0, 2.0);mat2 b = mat2(1.0, 2.0, 3.0, 4.0);vec2 a1 = a * 10.0; // a1 = vec2(10.0, 20.0)mat2 b1 = b * 10.0; // b1 = mat2(10.0, 20.0, 30.0, 40.0) 向量(vec)间的运算12345vec2 a = vec2(1.0, 2.0)vec2 b = vec2(0.1, 0.2)vec2 c = a + b; // c = vec2(1.1, 2.2)vec2 d = a * b; // c = vec2(0.1, 0.4) 向量(vec)与矩阵(mat)的运算要求运算数的阶数相同，运算规则与线性代数中的矩阵变换相同，运算结果为向量12345678vec2 v = vec2(10., 20.);mat2 m = mat2(1., 2., 3., 4.);vec2 w = m * v; // = vec2(1. * 10. + 3. * 20., 2. * 10. + 4. * 20.)...vec2 v = vec2(10., 20.);mat2 m = mat2(1., 2., 3., 4.);vec2 w = v * m; // = vec2(1. * 10. + 2. * 20., 3. * 10. + 4. * 20.) 矩阵间运算要求运算数的阶数相同。12345mat2 a = mat2(1., 2., 3., 4.);mat2 b = mat2(10., 20., 30., 40.);mat2 c = a * b; //mat2(1.*10.+3.*20.,2.*10.+4.*20.,1.* 30.+3.*40.,2.* 30.+4.*40.);mat2 d = a+b;//mat2(1.+10.,2.+20.,3.+30.,4.+40); GLSL常见内置变量 内置的顶点着色器变量 变量名 作用 gl_color 输入，对应于每个顶点的主颜色 gl_SecondaryColor 输入，对应于每个顶点的辅助颜色 gl_Normal 输入，对应于每个顶点的法线 gl_Vertex 输入，对应于每个物体的顶点位置 gl_MultiTexCoordn 输入，对应于每个顶点的纹理坐标ｎ gl_FogCoord 输入，对应于每个顶点的雾坐标 gl_Position 经过转换的顶点位置的输出，用于固定功能的图元的装配，裁剪和剔除，所有的顶点着色器必须写入到这个变量 gl_ClipVertex 坐标输出，用于用户裁剪平面的裁剪 gl_PointSize 需要进行光栅化的点的大小的输出，以像素为单位 gl_FrontColor 正面主颜色的varying的输出 gl_BackColor 背面主颜色的varying的输出 gl_FrontSecondaryColor 正面辅助颜色的varying的输出 gl_BackSecondaryColor 背面辅助颜色的varying的输出 gl_TexCoord[] 纹理坐标arying输出的数组 gl_FogFragCoord 雾坐标的输出 内置的片段着色器的变量 变量名 作用 gl_Color 包含主颜色的只读插值输入 gl_SecondaryColor 包含辅助颜色的只读插值输入数组 gl_TextCoord 纹理坐标的只读插值输入数组 gl_FragCoord 雾坐标的只读插值输入 gl_FrontFcing 只读的输入，如果他是一个正面图元的一部分，其值为ＴＲＵＥ gl_PointCoord 只适用于点图元并且当ＧＬ＿ＰＯＩＮＴ＿ＳＴＲＩＴＥ被启用时 gl_FragColor 颜色的输出，用于后续的基于像素的操作 gl_FragData[] glDrawBuffers 所使用的任意的数组 gl_FragDepth 深度的输出，用于后续的操作 OpenGL常见内建函数 (暂不添加多余文字介绍，仅作归纳方便查找) 角度和三角函数 指数函数 常用函数 几何函数 矩阵函数 向量相关函数 材质查找函数\\ 参考：GLSL 中文手册","categories":[{"name":"Android OpenGL","slug":"Android-OpenGL","permalink":"jaminchanks.github.io.git/categories/Android-OpenGL/"}],"tags":[]},{"title":"Android复习笔记","slug":"Android/Android复习笔记","date":"2018-01-17T18:02:16.233Z","updated":"2018-02-07T16:48:57.046Z","comments":true,"path":"2018/01/18/Android/Android复习笔记/","link":"","permalink":"jaminchanks.github.io.git/2018/01/18/Android/Android复习笔记/","excerpt":"1. Activity","text":"1. Activity 1. Activity的四种状态 running pauseed stopped killed 2. Activity的生命周期 onCreate() onStart() onResume() onPause() onStop() onDestroy() onRestart() 3. 进程的优先级 空进程：空进程是不包含任何活跃组件的进程。在系统资源紧张时会被首先清除。 前台进程：前台进程是Android系统中最重要的进程，是与用户正在交互的进程。* 服务进程：一个包含已启动服务的进程就是服务进程，服务没有用户界面，不与用户直接交互，但能够在后台长期运行，提供用户所关心的重要功能。 可见进程：可见进程指部分程序界面能够被用户看见，却不在前台与用户交互。 后台进程： 如果一个进程不包含任何已经启动的服务，而且没有用户可见的Activity，则这个进程就是后台进程。 以上进程的回收顺序从先到后分别是：空进程，后台进程，服务进程，可见进程，前台进程。 4. Activity的启动模式 Standard:每次新建Activity实例。 SingleTop：若栈顶为所需实例，不新建，否则新建。 SingleTask：若栈中已存在实例，将所需Activity置于栈顶，清除该Activity之上的其他Activity。 SingleInstance：将Activity置于新建的任务栈中，供需要的App共享使用 5. Scheme跳转协议Android中的scheme是一种页面内跳转协议，通过定义自己的scheme协议，可以跳转到app中的各个页面 服务器可以定制化告诉app跳转哪个页面 App可以通过跳转到另一个App页面 可以通过H5页面跳转页面 2. FragmentFragment比Activity更节省内存，其切换模式也更加舒适，使用频率不低于四大组件，且有自己的生命周期，而且必须依附于Activity。 1. Activity创建Fragment的方式 静态创建（xml中绑定fragment） 动态创建（代码中通过fragment事务管理器添加动态创建的fragment） 2. FragmentPageAdapter和FragmentPageStateAdapter的区别 FragmentPageAdapter在每次切换页面的的时候，是将Fragment进行分离，适合页面较少的Fragment使用以保存一些内存，对系统内存不会多大影响 FragmentPageStateAdapter在每次切换页面的时候，是将Fragment进行回收，适合页面较多的Fragment使用，这样就不会消耗更多的内存 3. fragment的生命周期 onAttach() onCreate() onCreateView() onActivityCreated() onStart() onResume() onPause() onStop() onDestroyView() onDestroy() onDetach() 4. Fragment的通信 Fragment调用Activity中的方法：getActivity Activity调用Fragment中的方法：接口回调 Fragment调用Fragment中的方法：FragmentManager. findFragmentById 5. Fragment的replace、add、remove方法 replace：替代Fragment的栈顶页面 add：添加Fragment到栈顶页面 remove：移除Fragment栈顶页面 3. ServiceService是四大组件之一，它可以在后台执行长时间运行操作而没有用户界面的应用组件 1. Service和Thread的区别 Service是安卓中系统的组件，它运行在独立进程的主线程中，不可以执行耗时操作。Thread是程序执行的最小单元，分配CPU的基本单位，可以开启子线程执行耗时操作。 Service在不同Activity中可以获取自身实例，可以方便的对Service进行操作。Thread在不同的Activity中难以获取自身实例，如果Activity被销毁，Thread实例就很难再获取得到。 2. Service启动方式 startService bindService（通过bindService方式可以在Activity中获取到Sevice的实例） 3. Service的生命周期 startService onCreate() onStartCommand() onDestroy() bindService onCreate() onBind() onUnBind() onDestroy() 4. Broadcast ReceiverBroadcast是四大组件之一，是一种广泛运用在应用程序之间传输信息的机制，通过发送Intent来传送我们的数据. 1. 使用场景 同一App具有多个进程的不同组件之间的消息通信 不同App之间的组件之间的消息通信 2. Broadcast Receiver的种类 普通广播：异步执行，效率高，无法被截断，所有的接收者同时接收到广播信息。 有序广播：同步执行，效率低，可以被截断，同一时刻只能有一个广播接收者接收到信息，该接收者处理完毕自己的逻辑之后该广播才能继续传递，所以这是的广播接收者是有顺序的。优先级高的广播接收者优先收到广播信息。此时广播是被截断的。 本地广播：只能在本地应用内部传递。通过localBroadcastManager类在注册和发送广播，通过localReceiver类来接收广播。 Sticky广播（粘性广播）：由于在Android5. 0 &amp; API 21中已经失效，可忽略。 3. Broadcast Receiver的实现 静态注册：注册后一直运行，尽管Activity、进程、App被杀死还是可以接收到广播 动态注册：跟随Activity的生命周期 4. Broadcast Receiver实现机制 《android开发艺术探索》有具体说明 自定义广播类继承BroadcastReceiver，复写onReceiver() 通过Binder机制向AMS进行注册广播 广播发送者通过Binder机制向AMS发送广播 AMS查找符合相应条件的广播发送到BroadcastReceiver相应的循环队列中 消息队列执行拿到广播，回调BroadcastReceiver的onReceiver() 5. LocalBroadcastManager特点 本地广播只能在自身App内传播，不必担心泄漏隐私数据 本地广播不允许其他App对你的App发送该广播，不必担心安全漏洞被利用 本地广播比全局广播更高效 以上三点都是源于其内部是用Handler实现的 4. WebView1. WebView安全漏洞 API16之前存在远程代码执行安全漏洞，该漏洞源于程序没有正确限制使用WebView.addJavascriptInterface方法，远程攻击者可通过使用Java反射机制利用该漏洞执行任意Java对象的方法。在Android4.2以上的，google作了修正，通过在Java的远程方法上面声明一个@JavascriptInterface。 2. WebView销毁步骤 * WebView在其他容器上时（如：LinearLayout），当销毁Activity时，需要在onDestroy()中先移除容器上的WebView，然后再将WebView.destroy()，这样就不会导致内存泄漏。 3. WebView的jsbridge 客户端和服务端之间可以通过Javascript来互相调用各自的方法 4. WebViewClient的onPageFinished WebViewClient的onPageFinished在每次完成页面的时候调用，但是遇到未加载完成的页面跳转其他页面时，就会一直调用，使用WebChromeClient. onProgressChanged可以替代。 5. WebView后台耗电 在WebView加载页面的时候，会自动开启线程去加载，如果不很好的关闭这些线程，就会导致电量消耗加大，可以采用暴力的方法，直接在onDestroy方法中System.exit(0)结束当前正在运行中的java虚拟机。 6. WebView硬件加速 Android3.0引入硬件加速，默认会开启，WebView在硬件加速的情况下滑动更加平滑，性能更加好，但是会出现白块或者页面闪烁的副作用，建议WebView暂时关闭硬件加速 7. WebView内存泄漏 *由于WebView是依附于Activity的，Activity的生命周期和WebView启动的线程的生命周期是不一致的，这会导致WebView一直持有对这个Activity的引用而无法释放，解决方案如下: 独立进程，简单暴力，不过可能涉及到进程间通信（推荐）。(在Webview所在的Activity的xml声明中指定 android:process=”:xxx”， 但是这里要注意跨进程通信的问题) 动态添加WebView，对传入WebView中使用的Context使用弱引用。 5. Binder 通过Parcelable而实现的跨进程间通信方式 1. Linux内核的基本知识 进程隔离/虚拟地址空间：进程间是不可以共享数据的，相当于被隔离，每个进程被分配到不同的虚拟地址中 系统调用：Linux内核对应用有访问权限，用户只能在应用层通过系统调用，调用内核的某些程序 binder驱动：它负责各个用户的进程，通过binder通信内核来进行交互的模块 2. 为什么使用Binder 性能上，相比传统的Socket更加高效 安全性高，支持协议双方互相校验 3. AIDL 客户端通过aidl文件的Stub.asInterface()方法，拿到Proxy代理类 通过调用Proxy代理类的方法，将参数进行封包后，调用底层的transact()方法 transact()方法会回调onTransact()方法，进行参数的解封 在onTransact()方法中调用服务端对应的方法，并将结果返回 6. Handler1. Handler是什么 Handler通过发送和处理Message和Runnable对象来关联相对应线程的MessageQueue 2. Handler使用方法 post(runnable) sendMessage(message) 3. Handler工作原理 Android进阶——Android消息机制之Looper、Handler、MessageQueen http://blog.csdn.net/qq_30379689/article/details/53394061 4. Handler引起的内存泄漏 原因：非静态内部类持有外部类的匿名引用，导致Activity无法释放 解决： Handler内部持有外部Activity的弱引用 Handler改为静态内部类 Handler.removeCallback() 7.AsyncTask1. AsyncTask是什么AyncTask本质上是一个封装了线程池和Handler的异步框架 2. 用法（略）3. AyncTask源码分析4. AsyncTask引起的内存泄漏 原因：非静态内部类持有外部类的匿名引用，导致Activity无法释放 解决： AsyncTask内部持有外部Activity的弱引用 AsyncTask改为静态内部类 AsyncTask.cancel() 5. AsyncTask的生命周期在Activity销毁之前，取消AsyncTask的运行，一次来保证程序的稳定 6. AsyncTask结果丢失由于屏幕旋转、Activity在内存紧张时被收回等情况下，Activity会被重新创建，此时，旧的AsyncTask持有酒的Activity引用，这个时候会导致AsyncTask的onPostExecute()对UI更新无效 7. AsyncTask并行/串行 AsyncTask在Android2.3之前默认采用并行执行任务，AsyncTask在Android2.3之后默认采用串行执行任务 如果需要在Android2.3之后采用并行执行任务，可以调用AsyncTask的executeOnExecutor() 8.HandlerThread面试题1. HandlerThread产生背景当系统有多个耗时任务需要执行时，每个任务都会开启一个新线程去执行耗时任务，这样会导致系统多次创建和销毁线程，从而影响性能，为了解决这一问题，Google提供了HandlerThread，HandlerThread在线程中创建一个Looper循环器，让Looper轮询消息队列，当有耗时任务进入队列时，则不需要开启新线程，在原有的线程中执行耗时任务即可，否则线程阻塞 2. HandlerThread的特点 HandlerThread本质上是一个线程，继承自Thread HandlerThread有自己的Looper对象，可以进行Looper循环，可以创建Handler HandlerThread可以在Handler的handlerMessage中执行异步方法 HandlerThread优点是异步不会阻塞，减少对性能的消耗 ??? HandlerThread缺点是不能同时继续进行多任务处理，需要等待进行处理，处理效率较低 HandlerThread与线程池不同，HandlerThread是一个串行队列，背后只有一个线程 9. IntentService1. IntentService是什么IntentService是继承自Service并处理异步请求的一个类，其内部采用HandlerThread和Handler实现的，在IntentService内有一个工作线程来处理耗时操作，其优先级比普通Service高。当任务完成后，IntentService会自动停止，而不需要手动调用stopSelf()。另外，可以多次启动IntentService，每个耗时操作都会以工作队列的方式在IntentService中的onHandlerIntent()回调方法中执行，并且每次只会执行一个工作线程。 2. IntentService的使用方法 创建Service继承自IntentService 复写构造方法和onHandlerIntent()方法 在onHandlerIntent()中执行耗时操作 10. 视图工作机制面试题《Android开发艺术探索》第三章 1. Android进阶——Android视图工作机制之measure、layout、drawhttp://blog.csdn.net/qq_30379689/article/details/54588736 2. Android事件分发机制之dispatchTouchEvent、onInterceptTouchEvent、onTouchEventhttp://blog.csdn.net/qq_30379689/article/details/53967177 3. Android视图工作机制中的重绘(1) invalidate()和requestLayout() invalidate()和requestLayout()，常用于View重绘和更新，其主要区别如下 invalidate方法只会执行onDraw方法requestLayout方法只会执行onMeasure方法和onLayout方法，并不会执行onDraw方法。所以当我们进行View更新时，若仅View的显示内容发生改变且新显示内容不影响View的大小、位置，则只需调用invalidate方法；若View宽高、位置发生改变且显示内容不变，只需调用requestLayout方法；若两者均发生改变，则需调用两者，按照View的绘制流程，推荐先调用requestLayout方法再调用invalidate方法 (2) invalidate()和postInvalidate() invalidate方法用于UI线程中重新绘制视图 postInvalidate方法用于非UI线程中重新绘制视图，省去使用handler 4. 事件分发dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()当点击事件发生时，首先Activity将TouchEvent传递给Window，再从Window传递给顶层View。TouchEvent会最先到达最顶层 view 的 dispatchTouchEvent ，然后由 dispatchTouchEvent 方法进行分发，如果dispatchTouchEvent返回true/false ，则将事件消耗，并且不再分发也不处理。如果dispatchTouchEvent交给super.dispatchTouchEvent(ev)去处理 ，则由这个 view 的 interceptTouchEvent 方法来决定是否要拦截这个事件，如果 interceptTouchEvent 返回 true ，也就是拦截掉了，则交给它的 onTouchEvent 来处理，如果 interceptTouchEvent 返回 false ，那么就传递给子 view ，由子 view 的 dispatchTouchEvent 再来开始这个事件的分发。如果事件传递到某一层的子 view 的 onTouchEvent 上了，这个方法返回了 false ，那么这个事件会从这个 view 往上传递，都是 onTouchEvent 来接收。而如果传递到最上面的 onTouchEvent 也返回 false 的话，这个事件就会“消失”，而且接收不到下一次事件。 11. ANR问题Application Not Responding,页面无响应的对话框 1. 发生ANR的条件应用程序的响应性是由ActivityManager和WindowManager系统服务监视的，当ANR发生条件满足时，就会弹出ANR的对话框 Activity超过5s无响应 BroadcastReceiver超过10s无响应 Service超过20s无响应 2. 造成ANR的主要原因主线程被IO操作阻塞 Activity的所有生命周期都是执行在主线程中的 Service默认执行在主线程中 BroadcastReceiver的回调onReceive()执行在主线程中 AsyncTask的回调除了doInBackground，其他都是执行在主线程中 没有使用子线程Looper的Handler的handlerMessage，post(Runnable)都是执行在主线程中 3. 如何解决ANR 在非UI线程中异步处理耗时IO操作 使用Thread或者HandlerThread提供优先级 使用Handler处理工作线程的耗时操作 AsyncTask的onCreate和onResume回调尽量避免耗时操作 12. OOMOOM指Out of memory（内存溢出），当前占用内存加上我们申请的内存资源超过了Dalvik虚拟机的最大内存限制就会抛出Out of memory异常 1. OOM相关概念 内存溢出：指程序在申请内存时，没有足够的空间供其使用 内存泄漏：指程序分配出去的内存不再使用，无法进行回收 内存抖动：指程序出现短时间内大量创建对象，并回收对象的现象 2. 解决OOM Bitmap 对图片进行压缩 加载缩略图 在滚动时不加载图片 回收Bitmap 使用inBitmap属性(复用内存块) 捕获异常 其他 listview重用convertView、使用Lru 避免onDraw方法执行对象的创建 谨慎使用多线程 13. Bitmap1. recycle 在安卓3.0以前Bitmap是存放在堆中的，我们只要回收堆内存即可 在安卓3.0以后Bitmap是存放在内存中的，我们需要回收native层和Java层的内存 官方建议我们3.0以后使用recycle方法进行回收，该方法也可以不主动调用，因为垃圾回收器会自动收集不可用的Bitmap对象进行回收 recycle方法会判断Bitmap在不可用的情况下，将发送指令到垃圾回收器，让其回收native层和Java层的内存，则Bitmap进入dead状态 recycle方法是不可逆的，如果再次调用getPixels()等方法，则获取不到想要的结果 2. 三级缓存 网络缓存 本地缓存 内存缓存 14. UI卡顿原理 View的绘制帧数保持60fps是最佳，这要求每帧的绘制时间不超过16ms（1000/60），如果安卓不能在16ms内完成界面的渲染，那么就会出现卡顿现象 1. UI卡顿的原因分析 在UI线程中做轻微的耗时操作，导致UI线程卡顿 布局Layout过于复杂，无法在16ms内完成渲染 在同一时间动画执行的次数过多，导致CPU和GPU负载过重 overDraw,导致像素在同一帧的时间内被绘制多次，使CPU和GPU负载过重 View频繁的触发measure、layout，导致measure、layout累计耗时过多和整个View频繁的重新渲染 频繁的处罚GC操作导致线程暂停，会使得安卓系统在16ms内无法完成绘制 冗余资源及逻辑等导致加载和执行缓慢 ANR 2. UI卡顿的优化 布局优化 使用include、ViewStub、merge 不要出现过于嵌套和冗余的布局 使用自定义View取代复杂的View ListView的优化 复用convertView 滑动不加载 背景和图片优化 缩略图 图片压缩 避免ANR 不要在UI线程中做耗时操作 15. 内存泄漏1. Java内存泄漏引起的主要原因长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏 2. Java内存分配策略 静态存储区：又称方法区，主要存储全局变量和静态变量，在整个程序运行期间都存在 栈区：方法体的局部变量会在栈区创建空间，并在方法执行结束后会自动释放变量的空间和内存 堆区：保存动态产生的数据，如：new出来的对象和数组，在不使用的时候由Java回收器自动回收 3. Android解决内存泄漏的例子 单例造成的内存泄漏：在单例中，使用context.getApplicationContext()作为单例的context 匿名内部类造成的内存泄漏：由于非静态内部类持有匿名外部类的引用，必须将内部类设置为static Handler造成的内存泄漏：使用static的Handler内部类，同时在实现内部类中持有Context的弱引用 避免使用static变量：由于static变量会跟Activity生命周期一致，当Activity退出后台被后台回收时，static变量是不安全，所以也要管理好static变量的生命周期 资源未关闭造成的内存泄漏：比如Socket、Broadcast、Cursor、Bitmap、ListView等，使用完后要关闭 AsyncTask造成的内存泄漏：由于非静态内部类持有匿名内部类的引用而造成内存泄漏，可以通过AsyncTask内部持有外部Activity的弱引用同时改为静态内部类或在onDestroy()中执行AsyncTask.cancel()进行修复 16. 内存管理面试题1. Android内存管理机制 分配机制 管理机制 2. 内存管理机制的特点 更少的占用内存 在合适的时候，合理的释放系统资源 在系统内存紧张的时候，能释放掉大部分不重要的资源 能合理的在特殊生命周期中，保存或还原重要数据 3. 内存优化方法 Service完成任务后应停止它，或用IntentService（因为可以自动停止服务）代替Service 在UI不可见的时候，释放其UI资源 在系统内存紧张的时候，尽可能多的释放非重要资源 避免滥用Bitmap导致内存浪费 避免使用依赖注入框架 使用针对内存优化过的数据容器 使用ZIP对齐的APK 使用多进程 17. 冷启动和热启动面试题1. 什么是冷启动和热启动 冷启动：在启动应用前，系统中没有该应用的任何进程信息 热启动：在启动应用时，在已有的进程上启动应用（用户使用返回键退出应用，然后马上又重新启动应用） 2. 冷启动和热启动的区别 冷启动：创建Application后再创建和初始化MainActivity 热启动：创建和初始化MainActivity即可 3. 冷启动时间的计算 这个时间值从应用启动（创建进程）开始计算，到完成视图的第一次绘制为止 4. 冷启动流程 Zygote进程中fork创建出一个新的进程 创建和初始化Application类、创建MainActivity inflate布局、当onCreate/onStart/onResume方法都走完 contentView的measure/layout/draw显示在界面上总结：Application构造方法-&gt;attachBaseContext()-&gt;onCreate()-&gt;Activity构造方法-&gt;onCreate()-&gt;配置主题中背景等属性-&gt;onStart()-&gt;onResume()-&gt;测量布局绘制显示在界面上 5. 冷启动优化 减少第一个界面onCreate()方法的工作量 不要让Application参与业务的操作 不要在Application进行耗时操作 不要以静态变量的方式在Application中保存数据 减少布局的复杂性和深度 不要在mainThread中加载资源 通过懒加载方式初始化第三方SDK 18. 其他优化面试题1. Android不用静态变量存储数据 静态变量等数据由于进程已经被杀死而被初始化 使用其他数据传输方式：文件/sp/contentProvider 2. SharePreference安全问题 不能跨进程同步 文件不宜过大 3. 内存对象序列化 Serializeble：是java的序列化方式，Serializeble在序列化的时候会产生大量的临时对象，从而引起频繁的GC Parcelable：是Android的序列化方式，且性能比Serializeble高，Parcelable不能使用在要将数据存储在硬盘上的情况 4. 避免在UI线程中做繁重的操作 19. 热更新面试题1. 热更新主要流程 线上检查到Crash 拉出Bugfix分支修复Crash问题 jenkins构建和补丁生成 app通过推送或主动拉取补丁文件 将Bugfix代码合到master上 2. 热更新主流框架 Dexposed AndFix Nuwa Tinker 3. 热更新的原理 在ClassLoader创建一个dexElements数组 将修复好的dex文件存放在dexElements数组的最前面 ClassLoader会遍历dexElements数组，找到最前面的dex文件优先加载 20. 进程保活面试题1. 进程的优先级 空进程 后台进程 服务进程 可见进程 前台进程 2. Android进程回收策略 Low memory Killer（定时执行）：通过一些比较复杂的评分机制，对进程进行打分，然后将分数高的进程判定为bad进程，杀死并释放内存 OOM_ODJ：判别进程的优先级 3. Android保活方案 利用系统广播拉活 利用系统Service机制拉活 利用Native进程拉活 利用JobScheduler机制拉活 利用账号同步机制拉活 原文链接","categories":[{"name":"Android","slug":"Android","permalink":"jaminchanks.github.io.git/categories/Android/"}],"tags":[]}]}